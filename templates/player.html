<!doctype html>
<html>
  <head>
    <title>MP3 Player</title>
    <script src="https://unpkg.com/htmx.org@1.9.10"></script>
    <style>
      body {
        font-family: Arial, sans-serif;
        max-width: 800px;
        margin: 50px auto;
        padding: 20px;
      }

      #player-controls {
        background: #f0f0f0;
        padding: 20px;
        border-radius: 8px;
        margin-bottom: 20px;
      }

      .controls {
        display: flex;
        gap: 10px;
        margin-top: 20px;
      }

      button {
        padding: 10px 20px;
        font-size: 16px;
        cursor: pointer;
        border: none;
        background: #007bff;
        color: white;
        border-radius: 4px;
      }

      button:hover {
        background: #0056b3;
      }

      button:disabled {
        background: #6c757d;
        cursor: not-allowed;
      }

      audio {
        width: 100%;
        margin-top: 20px;
      }

      .song-info {
        font-size: 18px;
        margin-bottom: 10px;
      }

      /* Radio Mode Styles */
      .mode-container {
        background: #e9ecef;
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 20px;
      }

      .mode-indicator {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 10px;
      }

      .mode-badge {
        padding: 5px 12px;
        border-radius: 12px;
        font-weight: bold;
        font-size: 14px;
      }

      .mode-badge.private {
        background: #28a745;
        color: white;
      }

      .mode-badge.radio {
        background: #dc3545;
        color: white;
      }

      .mode-badge.broadcasting {
        background: #ffc107;
        color: black;
      }

      .radio-controls {
        display: grid;
        gap: 10px;
        margin-top: 15px;
      }

      .radio-input-group {
        display: flex;
        gap: 10px;
      }

      .radio-input-group input {
        flex: 1;
        padding: 8px;
        border: 1px solid #ced4da;
        border-radius: 4px;
        font-size: 14px;
      }

      .radio-input-group button {
        flex-shrink: 0;
      }

      .broadcaster-info {
        background: #fff;
        padding: 10px;
        border-radius: 4px;
        margin-top: 10px;
        font-size: 14px;
      }

      .session-id-display {
        background: #fff;
        padding: 10px;
        border-radius: 4px;
        margin-top: 10px;
        font-size: 14px;
        font-family: monospace;
      }

      .hidden {
        display: none;
      }

      #debug-log {
        background: #000;
        color: #0f0;
        padding: 10px;
        border-radius: 4px;
        margin-top: 20px;
        font-family: monospace;
        font-size: 12px;
        max-height: 200px;
        overflow-y: auto;
      }

      .analytics-container {
        background: #f8f9fa;
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 20px;
        border: 1px solid #dee2e6;
      }

      .analytics-container h3 {
        margin: 0 0 10px 0;
        font-size: 16px;
        color: #495057;
      }

      #analytics-display {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 15px;
      }

      .stat {
        background: white;
        padding: 10px;
        border-radius: 6px;
        text-align: center;
        border: 1px solid #e9ecef;
      }

      .stat-label {
        display: block;
        font-size: 12px;
        color: #6c757d;
        margin-bottom: 5px;
      }

      .stat-value {
        display: block;
        font-size: 24px;
        font-weight: bold;
        color: #007bff;
      }

      .broadcasters-container {
        background: #f8f9fa;
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 20px;
        border: 1px solid #dee2e6;
      }

      .broadcasters-container h3 {
        margin: 0 0 15px 0;
        font-size: 16px;
        color: #495057;
      }

      #broadcasters-list {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      .no-broadcasters {
        text-align: center;
        color: #6c757d;
        padding: 20px;
        font-style: italic;
      }

      .broadcaster-card {
        background: white;
        padding: 15px;
        border-radius: 6px;
        border: 1px solid #e9ecef;
        display: flex;
        align-items: center;
        justify-content: space-between;
        transition: box-shadow 0.2s;
      }

      .broadcaster-card:hover {
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }

      .broadcaster-info-card {
        flex: 1;
      }

      .broadcaster-id {
        font-size: 12px;
        color: #6c757d;
        font-family: monospace;
        margin-bottom: 5px;
      }

      .broadcaster-song {
        font-size: 14px;
        font-weight: 600;
        color: #212529;
        margin-bottom: 5px;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .play-status {
        font-size: 16px;
      }

      .broadcaster-time {
        font-size: 12px;
        color: #6c757d;
      }

      .tune-in-btn {
        padding: 8px 16px;
        font-size: 14px;
        background: #007bff;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        white-space: nowrap;
      }

      .tune-in-btn:hover {
        background: #0056b3;
      }

      .tune-in-btn:disabled {
        background: #6c757d;
        cursor: not-allowed;
      }

      .currently-tuned {
        background: #d4edda;
        border-color: #c3e6cb;
      }

      .self-broadcasting {
        background: #fff3cd;
        border-color: #ffeaa7;
      }

      .mobile-warning {
        background: #fff3cd;
        border: 1px solid #ffc107;
        padding: 10px;
        border-radius: 4px;
        margin-bottom: 10px;
        font-size: 14px;
      }

      .connection-status {
        background: #fff;
        padding: 8px 12px;
        border-radius: 4px;
        margin-top: 10px;
        font-size: 13px;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      #connection-text {
        font-weight: 500;
      }
    </style>
  </head>
  <body>
    <h1>MP3 Player</h1>

    <div class="analytics-container">
      <h3>üìä Server Statistics (Live)</h3>
      <div id="analytics-display">
        <div class="stat">
          <span class="stat-label">Active Connections:</span>
          <span id="stat-connections" class="stat-value">0</span>
        </div>
        <div class="stat">
          <span class="stat-label">Broadcasting:</span>
          <span id="stat-broadcasters" class="stat-value">0</span>
        </div>
        <div class="stat">
          <span class="stat-label">Listening:</span>
          <span id="stat-listeners" class="stat-value">0</span>
        </div>
      </div>
    </div>

    <!-- Live Broadcasts -->
    <div class="broadcasters-container">
      <h3>üìª Live Broadcasts</h3>
      <div id="broadcasters-list">
        <div class="no-broadcasters">No one is broadcasting right now</div>
      </div>
    </div>

    <!-- Mobile Warning -->
    <div id="mobile-warning" class="mobile-warning hidden">
      ‚ö†Ô∏è Broadcasting on mobile may stop when the screen locks or you switch apps. 
      Keep this tab active for best results.
    </div>

    <!-- Mode Indicator and Radio Controls -->
    <div class="mode-container">
      <div class="mode-indicator">
        <span id="mode-display" class="mode-badge private">Private Mode</span>
        <span id="broadcast-status" class="mode-badge broadcasting hidden"
          >Broadcasting</span
        >
      </div>

      <div class="connection-status">
        <span id="connection-indicator">üü°</span>
        <span id="connection-text">Connecting...</span>
      </div>

      <div class="session-id-display">
        <strong>Your Session ID:</strong>
        <span id="my-session-id">{{ session_id }}</span>
        <button
          onclick="copySessionId()"
          style="margin-left: 10px; padding: 5px 10px; font-size: 12px"
        >
          üìã Copy
        </button>
      </div>

      <div id="broadcaster-info" class="broadcaster-info hidden">
        Tuned into: <strong id="broadcaster-name"></strong>
      </div>

      <div class="radio-controls">
        <!-- Tune In -->
        <div class="radio-input-group">
          <input
            type="text"
            id="broadcaster-input"
            placeholder="Paste broadcaster's session ID here..."
            value=""
          />
          <button id="tune-in-btn">üìª Tune In</button>
          <button id="tune-out-btn" class="hidden">üè† Back to Private</button>
        </div>

        <!-- Broadcasting Controls -->
        <div class="radio-input-group">
          <button id="broadcast-btn">üì° Start Broadcasting</button>
          <button id="stop-broadcast-btn" class="hidden">
            ‚èπÔ∏è Stop Broadcasting
          </button>
        </div>
      </div>
    </div>

    <!-- Player Controls (existing) -->
    <div id="player-controls">
      <div class="song-info">
        <strong>Now Playing:</strong> {{ current_song }}
      </div>
      <div>Track {{ current_index + 1 }} of {{ total_songs }}</div>
    </div>

    <!-- Audio Player -->
    <audio id="audio-player" controls>
      <source src="/player/stream/{{ current_index }}" type="audio/mpeg" />
      Your browser doesn't support audio playback.
    </audio>

    <!-- Playback Controls -->
    <div class="controls">
      <button
        id="prev-btn"
        hx-post="/player/prev"
        hx-target="#player-controls"
        hx-swap="innerHTML"
      >
        ‚èÆÔ∏è Previous
      </button>

      <button
        id="next-btn"
        hx-post="/player/next"
        hx-target="#player-controls"
        hx-swap="innerHTML"
      >
        Next ‚è≠Ô∏è
      </button>
    </div>

    <!-- Debug Log -->
    <div id="debug-log"></div>

    <script>
      // Debug logging
      function debugLog(message) {
        const log = document.getElementById("debug-log");
        const time = new Date().toLocaleTimeString();
        log.innerHTML += `[${time}] ${message}<br>`;
        log.scrollTop = log.scrollHeight;
        console.log(message);
      }

      function copySessionId() {
        const sessionId = document.getElementById("my-session-id").textContent;
        navigator.clipboard.writeText(sessionId);
        debugLog("Session ID copied to clipboard");
      }

      // Radio Player Class
      class RadioPlayer {
        constructor(audioElement, sessionId) {
          this.audio = audioElement;
          this.sessionId = sessionId;
          this.mode = "private";
          this.tunedBroadcaster = null;
          this.ws = null;
          this.heartbeatInterval = null;
          this.targetTime = 0;
          this.isBroadcasting = false;
          this.isStartingBroadcast = false;
          this.wakeLock = null;
          this.pageHiddenAt = null;

          // Reconnection state
          this.reconnectAttempts = 0;
          this.maxReconnectAttempts = 10;
          this.baseReconnectDelay = 500;
          this.maxReconnectDelay = 30000;
          this.reconnectTimer = null;
          this.isIntentionalDisconnect = false;

          // Event listener tracking for cleanup
          this.boundHandlers = new Map();
          this.audioEventHandlers = new Map();

          // Connection state for UI
          this.connectionState = "disconnected";

          debugLog(`Initialized with session ID: ${sessionId}`);
          
          // Setup page visibility handling
          this.setupPageVisibilityHandling();
        }

        isMobile() {
          return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
            navigator.userAgent
          );
        }

        setupPageVisibilityHandling() {
          let visibilityProp = 'hidden';
          let visibilityEvent = 'visibilitychange';
          
          if (typeof document.hidden !== 'undefined') {
            visibilityProp = 'hidden';
            visibilityEvent = 'visibilitychange';
          } else if (typeof document.webkitHidden !== 'undefined') {
            visibilityProp = 'webkitHidden';
            visibilityEvent = 'webkitvisibilitychange';
          }
          
          document.addEventListener(visibilityEvent, () => {
            if (document[visibilityProp]) {
              debugLog("üì± Page hidden - broadcasting may be affected on mobile");
              this.onPageHidden();
            } else {
              debugLog("üëÅÔ∏è Page visible again");
              this.onPageVisible();
            }
          });
        }

        onPageHidden() {
          this.pageHiddenAt = Date.now();
          
          if (this.isBroadcasting) {
            debugLog("üì± Page backgrounded - JavaScript will be throttled");
            // DON'T speed up heartbeats - browser throttles anyway, it's pointless
            this.releaseWakeLock();
          }
        }

        onPageVisible() {
          const hiddenDuration = this.pageHiddenAt ? (Date.now() - this.pageHiddenAt) / 1000 : 0;
          this.pageHiddenAt = null;
          
          debugLog(`üëÅÔ∏è Page visible again (was hidden for ${hiddenDuration.toFixed(1)}s)`);
          
          // Reconnect if needed
          if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
            debugLog("WebSocket disconnected, reconnecting...");
            this.connectWebSocket();
          }
          
          if (this.isBroadcasting) {
            // If we were hidden for less than 40 seconds, just resume broadcasting
            // The server's timeout is 45s, so if we were hidden < 40s, we should still be valid
            if (hiddenDuration < 40) {
              debugLog("‚úì Resuming broadcast (short background duration)");
              
              // Re-acquire wake lock
              this.requestWakeLock();
              
              // Send an immediate heartbeat to tell server we're still here
              if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                this.sendHeartbeat();
              }
            } else {
              // We were backgrounded for a long time, server probably cleaned us up
              debugLog("‚ö†Ô∏è Long background duration - verifying broadcast state");
              this.verifyBroadcastState();
            }
          }
        }

        async requestWakeLock() {
          if (!('wakeLock' in navigator)) {
            debugLog("Wake Lock API not supported");
            return;
          }
          
          try {
            this.wakeLock = await navigator.wakeLock.request('screen');
            debugLog("‚úì Wake lock acquired - screen will stay on");
            
            this.wakeLock.addEventListener('release', () => {
              debugLog("Wake lock released");
            });
          } catch (err) {
            debugLog(`Wake lock error: ${err.message}`);
          }
        }

        async releaseWakeLock() {
          if (this.wakeLock) {
            try {
              await this.wakeLock.release();
              this.wakeLock = null;
              debugLog("Wake lock released");
            } catch (err) {
              debugLog(`Wake lock release error: ${err.message}`);
            }
          }
        }

        async verifyBroadcastState() {
          if (!this.ws || this.ws.readyState !== WebSocket.OPEN) return;
          
          const msg = {
            type: "QueryBroadcastState",
            session_id: this.sessionId
          };
          
          debugLog("‚Üí Querying broadcast state from server");
          this.ws.send(JSON.stringify(msg));
        }

        getReconnectDelay() {
          const exponential =
            this.baseReconnectDelay * Math.pow(2, this.reconnectAttempts);
          const jitter = exponential * 0.2 * (Math.random() - 0.5);
          const delay = Math.min(
            Math.max(this.baseReconnectDelay, exponential + jitter),
            this.maxReconnectDelay,
          );
          return delay;
        }

        updateConnectionState(newState) {
          this.connectionState = newState;
          this.notifyConnectionChange(newState);
        }

        notifyConnectionChange(state) {
          const indicator = document.getElementById('connection-indicator');
          const text = document.getElementById('connection-text');
          
          const states = {
            connected: { icon: 'üü¢', text: 'Connected', color: '#28a745' },
            connecting: { icon: 'üü°', text: 'Connecting...', color: '#ffc107' },
            disconnected: { icon: '‚ö™', text: 'Disconnected', color: '#6c757d' },
            error: { icon: 'üî¥', text: 'Connection Error', color: '#dc3545' }
          };
          
          const config = states[state] || states.disconnected;
          indicator.textContent = config.icon;
          text.textContent = config.text;
          text.style.color = config.color;
          
          const event = new CustomEvent("connectionStateChange", {
            detail: {
              state,
              attempt: this.reconnectAttempts,
              maxAttempts: this.maxReconnectAttempts,
            },
          });
          document.dispatchEvent(event);
        }

        connectWebSocket() {
          if (
            this.ws &&
            (this.ws.readyState === WebSocket.OPEN ||
              this.ws.readyState === WebSocket.CONNECTING)
          ) {
            debugLog(
              `WebSocket already ${this.ws.readyState === WebSocket.OPEN ? "connected" : "connecting"}, skipping...`,
            );
            return;
          }

          if (this.reconnectTimer) {
            clearTimeout(this.reconnectTimer);
            this.reconnectTimer = null;
          }

          this.updateConnectionState("connecting");

          const protocol =
            window.location.protocol === "https:" ? "wss:" : "ws:";
          const wsUrl = `${protocol}//${window.location.host}/player/radio`;

          debugLog(
            `Connecting to WebSocket: ${wsUrl} (attempt ${this.reconnectAttempts + 1})`,
          );

          try {
            this.ws = new WebSocket(wsUrl);
          } catch (error) {
            debugLog(`Failed to create WebSocket: ${error.message}`);
            this.scheduleReconnect();
            return;
          }

          const onOpen = () => {
            debugLog("‚úì WebSocket connected");
            this.reconnectAttempts = 0;
            this.updateConnectionState("connected");

            // DON'T auto-resume broadcasting - verify first
            if (this.isBroadcasting) {
              debugLog("Client thinks it's broadcasting - verifying with server");
              this.verifyBroadcastState();
            }

            if (this.tunedBroadcaster) {
              debugLog(
                `Re-tuning to ${this.tunedBroadcaster} after reconnection`,
              );
              this.tuneIn(this.tunedBroadcaster);
            }
          };

          const onMessage = (event) => {
            debugLog(`‚Üê Received: ${event.data}`);
            try {
              const msg = JSON.parse(event.data);
              this.handleRadioMessage(msg);
            } catch (error) {
              debugLog(`Failed to parse message: ${error.message}`);
            }
          };

          const onError = (error) => {
            debugLog(`‚úó WebSocket error`);
            this.updateConnectionState("error");
          };

          const onClose = (event) => {
            debugLog(
              `WebSocket closed (code: ${event.code}, clean: ${event.wasClean})`,
            );
            this.updateConnectionState("disconnected");

            this.removeWebSocketHandlers();

            if (!this.isIntentionalDisconnect) {
              this.scheduleReconnect();
            } else {
              debugLog("Intentional disconnect, not reconnecting");
              this.isIntentionalDisconnect = false;
            }
          };

          this.boundHandlers.set("open", onOpen);
          this.boundHandlers.set("message", onMessage);
          this.boundHandlers.set("error", onError);
          this.boundHandlers.set("close", onClose);

          this.ws.addEventListener("open", onOpen);
          this.ws.addEventListener("message", onMessage);
          this.ws.addEventListener("error", onError);
          this.ws.addEventListener("close", onClose);
        }

        scheduleReconnect() {
          if (this.reconnectAttempts >= this.maxReconnectAttempts) {
            debugLog(
              `Max reconnection attempts (${this.maxReconnectAttempts}) reached`,
            );
            this.updateConnectionState("error");
            alert(
              "Unable to connect to server after multiple attempts. Please refresh the page.",
            );
            return;
          }

          const delay = this.getReconnectDelay();
          debugLog(
            `Scheduling reconnection in ${delay}ms (attempt ${this.reconnectAttempts + 1}/${this.maxReconnectAttempts})`,
          );

          this.reconnectTimer = setTimeout(() => {
            this.reconnectAttempts++;
            this.connectWebSocket();
          }, delay);
        }

        removeWebSocketHandlers() {
          if (!this.ws) return;

          this.boundHandlers.forEach((handler, event) => {
            this.ws.removeEventListener(event, handler);
          });
          this.boundHandlers.clear();
        }

        disconnect() {
          this.isIntentionalDisconnect = true;

          if (this.reconnectTimer) {
            clearTimeout(this.reconnectTimer);
            this.reconnectTimer = null;
          }

          if (this.isBroadcasting) {
            this.stopBroadcasting();
          }

          if (this.ws) {
            this.removeWebSocketHandlers();
            if (
              this.ws.readyState === WebSocket.OPEN ||
              this.ws.readyState === WebSocket.CONNECTING
            ) {
              this.ws.close();
            }
            this.ws = null;
          }

          this.updateConnectionState("disconnected");
          debugLog("Disconnected");
        }

        handleRadioMessage(msg) {
          if (msg.type === "Sync" && msg.broadcaster_id === this.sessionId) {
            return;
          }

          debugLog(`Handling message type: ${msg.type}, mode: ${this.mode}`);

          if (msg.type === "Analytics") {
            updateAnalyticsDisplay(msg);
            return;
          }

          if (msg.type === "BroadcastStateResponse") {
            debugLog(`Server says broadcasting: ${msg.is_broadcasting}, client thinks: ${this.isBroadcasting}`);
            
            if (msg.is_broadcasting !== this.isBroadcasting) {
              debugLog(`‚ö†Ô∏è State mismatch detected!`);
              
              if (msg.is_broadcasting && !this.isBroadcasting) {
                // Server thinks we're broadcasting but we're not - sync to server
                this.isBroadcasting = true;
                this.updateBroadcastingUI(true);
                if (this.isMobile()) {
                  document.getElementById('mobile-warning').classList.remove('hidden');
                }
              } else if (!msg.is_broadcasting && this.isBroadcasting) {
                // Server says we're not broadcasting, but we think we are
                // This likely happened due to tab backgrounding - just resume broadcasting
                debugLog("üîÑ Server lost our session - resuming broadcast automatically");
                
                // Re-start broadcasting (will send StartBroadcasting message)
                const wasPlaying = !this.audio.paused;
                const currentTime = this.audio.currentTime;
                const currentIndex = this.getCurrentSongIndex();
                
                // Send StartBroadcasting to re-register with server
                const initMsg = {
                  type: "StartBroadcasting",
                  broadcaster_id: this.sessionId,
                  song_index: currentIndex,
                  playback_time: currentTime,
                  is_playing: wasPlaying,
                };
                
                debugLog(`‚Üí Resuming broadcast: song ${initMsg.song_index}, time ${initMsg.playback_time.toFixed(2)}s`);
                
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                  this.ws.send(JSON.stringify(initMsg));
                }
                
                // Don't show error alert - just seamlessly resume
              }
            }
            return;
          }

          if (msg.type === "Error") {
            debugLog(`Server error: ${msg.message}`);
            
            if (msg.message.includes("BroadcasterNotFound") || 
                msg.message.includes("not broadcasting")) {
              
              if (this.isBroadcasting) {
                debugLog("Server rejected broadcast - stopping");
                this.stopBroadcasting();
                alert("Your broadcast session ended. Please start broadcasting again if needed.");
              }
            } else {
              alert(`Error: ${msg.message}`);
            }
            return;
          }

          if (msg.type === "BroadcasterOffline") {
            if (this.tunedBroadcaster === msg.broadcaster_id) {
              debugLog(`Broadcaster ${msg.broadcaster_id} went offline`);
              alert(
                "The broadcaster you were listening to has stopped broadcasting.",
              );
              this.tuneOut("broadcaster_offline");
            }
            return;
          }

          if (msg.type === "BroadcasterOnline") {
            if (this.tunedBroadcaster === msg.broadcaster_id) {
              debugLog(`User ${msg.broadcaster_id} is now broadcasting`);
            }
            return;
          }

          if (this.mode !== "radio") return;

          switch (msg.type) {
            case "Sync":
              this.syncToBroadcaster(msg);
              break;
            case "Heartbeat":
              this.adjustForDrift(msg);
              break;
          }
        }

        syncToBroadcaster(msg) {
          const { song_index, playback_time, is_playing, server_timestamp_ms } =
            msg;

          const now = Date.now();
          const elapsed = (now - server_timestamp_ms) / 1000;

          this.targetTime = is_playing
            ? playback_time + elapsed
            : playback_time;

          const currentIndex = this.getCurrentSongIndex();

          if (currentIndex !== song_index) {
            debugLog(
              `Switching from song ${currentIndex} to song ${song_index}`,
            );
            this.audio.src = `/player/stream/${song_index}`;
            this.audio.load();

            htmx.ajax(
              "GET",
              `/player/controls?broadcaster=${this.tunedBroadcaster}`,
              { target: "#player-controls", swap: "innerHTML" },
            );
          }

          this.audio.currentTime = this.targetTime;

          if (is_playing && this.audio.paused) this.audio.play();
          if (!is_playing && !this.audio.paused) this.audio.pause();
        }

        adjustForDrift(msg) {
          if (this.audio.paused) return;

          const { playback_time, server_timestamp_ms } = msg;

          const now = Date.now();
          const elapsed = (now - server_timestamp_ms) / 1000;
          this.targetTime = playback_time + elapsed;

          const drift = Math.abs(this.audio.currentTime - this.targetTime);

          if (drift > 0.25) {
            debugLog(`Drift: ${drift.toFixed(3)}s - correcting`);
            this.audio.currentTime = this.targetTime;
          }
        }

        tuneIn(broadcasterId) {
          if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
            debugLog("WebSocket not ready, connecting...");
            this.connectWebSocket();
            setTimeout(() => this.tuneIn(broadcasterId), 500);
            return;
          }

          if (
            this.tunedBroadcaster &&
            this.tunedBroadcaster !== broadcasterId
          ) {
            debugLog(
              `Switching from ${this.tunedBroadcaster} to ${broadcasterId}`,
            );
            this.ws.send(JSON.stringify({ type: "TuneOut" }));
          }

          this.mode = "radio";
          this.tunedBroadcaster = broadcasterId;

          const msg = {
            type: "TuneIn",
            broadcaster_id: broadcasterId,
          };

          debugLog(`‚Üí Sending TuneIn: ${JSON.stringify(msg)}`);
          this.ws.send(JSON.stringify(msg));

          audio.controls = false;
        }

        tuneOut(reason = "manual") {
          debugLog(`Leaving radio mode: ${reason}`);

          if (this.ws && this.ws.readyState === WebSocket.OPEN) {
            this.ws.send(JSON.stringify({ type: "TuneOut" }));
          }

          this.mode = "private";
          this.tunedBroadcaster = null;

          modeDisplay.textContent = "Private Mode";
          modeDisplay.className = "mode-badge private";
          broadcasterInfo.classList.add("hidden");

          tuneOutBtn.classList.add("hidden");
          tuneInBtn.classList.remove("hidden");

          prevBtn.disabled = false;
          nextBtn.disabled = false;
          audio.controls = true;
        }

        removeAudioBroadcastListeners() {
          this.audioEventHandlers.forEach((handler, event) => {
            this.audio.removeEventListener(event, handler);
          });
          this.audioEventHandlers.clear();
        }

        sendHeartbeat() {
          if (!this.isBroadcasting) return;
          if (!this.ws || this.ws.readyState !== WebSocket.OPEN) return;
          
          const msg = {
            type: "Heartbeat",
            broadcaster_id: this.sessionId,
            playback_time: this.audio.currentTime,
          };
          
          debugLog(
            `‚Üí Heartbeat: song ${this.getCurrentSongIndex()}, time ${msg.playback_time.toFixed(2)}s`,
          );
          this.ws.send(JSON.stringify(msg));
        }

        startBroadcasting() {
          if (this.isStartingBroadcast) {
            debugLog("Already starting broadcast, ignoring duplicate request");
            return;
          }
          
          this.isStartingBroadcast = true;
          
          if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
            debugLog("WebSocket not ready for broadcasting, connecting...");
            this.isStartingBroadcast = false;
            this.connectWebSocket();
            setTimeout(() => this.startBroadcasting(), 500);
            return;
          }

          if (this.isBroadcasting) {
            debugLog("Already broadcasting, cleaning up first");
            this.stopBroadcasting();
          }

          // Remove any existing listeners first
          this.removeAudioBroadcastListeners();

          this.isBroadcasting = true;
          debugLog(`Broadcasting as: ${this.sessionId}`);

          // Show mobile warning if applicable
          if (this.isMobile()) {
            document.getElementById('mobile-warning').classList.remove('hidden');
          }

          // Request wake lock to prevent screen from sleeping
          this.requestWakeLock();

          const sendUpdate = () => {
            if (!this.isBroadcasting) return;
            if (!this.ws || this.ws.readyState !== WebSocket.OPEN) return;
            
            const msg = {
              type: "BroadcastUpdate",
              broadcaster_id: this.sessionId,
              song_index: this.getCurrentSongIndex(),
              playback_time: this.audio.currentTime,
              is_playing: !this.audio.paused,
            };
            debugLog(
              `‚Üí Broadcasting: song ${msg.song_index}, time ${msg.playback_time.toFixed(2)}s`,
            );
            this.ws.send(JSON.stringify(msg));
          };

          // Store handlers for cleanup
          this.audioEventHandlers.set("play", sendUpdate);
          this.audioEventHandlers.set("pause", sendUpdate);
          this.audioEventHandlers.set("seeked", sendUpdate);

          this.audio.addEventListener("play", sendUpdate);
          this.audio.addEventListener("pause", sendUpdate);
          this.audio.addEventListener("seeked", sendUpdate);

          this.heartbeatInterval = setInterval(() => this.sendHeartbeat(), 2000);

          // Send initial state
          const initMsg = {
            type: "StartBroadcasting",
            broadcaster_id: this.sessionId,
            song_index: this.getCurrentSongIndex(),
            playback_time: this.audio.currentTime,
            is_playing: !this.audio.paused,
          };
          debugLog(
            `‚Üí Starting broadcast: song ${initMsg.song_index}, time ${initMsg.playback_time.toFixed(2)}s`,
          );
          this.ws.send(JSON.stringify(initMsg));
          
          this.updateBroadcastingUI(true);
          this.isStartingBroadcast = false;
        }

        stopBroadcasting() {
          if (!this.isBroadcasting) {
            debugLog("Not broadcasting, nothing to stop");
            return;
          }
          
          this.isBroadcasting = false;

          if (this.heartbeatInterval) {
            clearInterval(this.heartbeatInterval);
            this.heartbeatInterval = null;
          }

          this.removeAudioBroadcastListeners();
          
          // Release wake lock
          this.releaseWakeLock();
          
          // Hide mobile warning
          document.getElementById('mobile-warning').classList.add('hidden');

          if (this.ws && this.ws.readyState === WebSocket.OPEN) {
            this.ws.send(
              JSON.stringify({
                type: "StopBroadcasting",
                broadcaster_id: this.sessionId,
              }),
            );
          }

          this.updateBroadcastingUI(false);
          debugLog("Broadcasting stopped");
        }

        updateBroadcastingUI(isBroadcasting) {
          const broadcastStatus = document.getElementById("broadcast-status");
          const broadcastBtn = document.getElementById("broadcast-btn");
          const stopBroadcastBtn = document.getElementById("stop-broadcast-btn");
          
          if (isBroadcasting) {
            broadcastStatus.classList.remove("hidden");
            broadcastBtn.classList.add("hidden");
            stopBroadcastBtn.classList.remove("hidden");
          } else {
            broadcastStatus.classList.add("hidden");
            stopBroadcastBtn.classList.add("hidden");
            broadcastBtn.classList.remove("hidden");
          }
        }

        getCurrentSongIndex() {
          const match = this.audio.src.match(/\/stream\/(\d+)/);
          return match ? parseInt(match[1]) : 0;
        }

        isInRadioMode() {
          return this.mode === "radio";
        }
      }

      // Update analytics display with live data
      function updateAnalyticsDisplay(analytics) {
        document.getElementById("stat-connections").textContent =
          analytics.active_connections;
        document.getElementById("stat-broadcasters").textContent =
          analytics.active_broadcasters;
        document.getElementById("stat-listeners").textContent =
          analytics.active_listeners;

        const broadcastersList = document.getElementById("broadcasters-list");

        if (analytics.broadcasters.length === 0) {
          broadcastersList.innerHTML =
            '<div class="no-broadcasters">No one is broadcasting right now</div>';
          return;
        }

        broadcastersList.innerHTML = analytics.broadcasters
          .map((broadcaster) => {
            const playIcon = broadcaster.is_playing ? "‚ñ∂Ô∏è" : "‚è∏Ô∏è";
            const minutes = Math.floor(broadcaster.playback_time / 60);
            const seconds = Math.floor(broadcaster.playback_time % 60);
            const timeStr = `${minutes}:${seconds.toString().padStart(2, "0")}`;

            const isSelf = broadcaster.broadcaster_id === player.sessionId;
            const isTunedIn =
              player.tunedBroadcaster === broadcaster.broadcaster_id;

            let cardClass = "broadcaster-card";
            if (isSelf) {
              cardClass += " self-broadcasting";
            } else if (isTunedIn) {
              cardClass += " currently-tuned";
            }

            let buttonHTML;
            if (isSelf) {
              buttonHTML = '<button class="tune-in-btn" disabled>You</button>';
            } else if (isTunedIn) {
              buttonHTML =
                '<button class="tune-in-btn" disabled>Tuned In ‚úì</button>';
            } else {
              buttonHTML = `<button class="tune-in-btn" onclick="tuneInToBroadcaster('${broadcaster.broadcaster_id}')">Tune In üìª</button>`;
            }

            return `
        <div class="${cardClass}">
          <div class="broadcaster-info-card">
            <div class="broadcaster-id">${broadcaster.broadcaster_id}</div>
            <div class="broadcaster-song">
              <span class="play-status">${playIcon}</span>
              <span>${broadcaster.song_name}</span>
            </div>
            <div class="broadcaster-time">
              Track ${broadcaster.song_index + 1} ‚Ä¢ ${timeStr}
            </div>
          </div>
          ${buttonHTML}
        </div>
      `;
          })
          .join("");
      }

      function tuneInToBroadcaster(broadcasterId) {
        document.getElementById("broadcaster-input").value = broadcasterId;

        player.tuneIn(broadcasterId);

        modeDisplay.textContent = "Radio Mode";
        modeDisplay.className = "mode-badge radio";
        broadcasterName.textContent = broadcasterId;
        broadcasterInfo.classList.remove("hidden");

        tuneInBtn.classList.add("hidden");
        tuneOutBtn.classList.remove("hidden");

        prevBtn.disabled = true;
        nextBtn.disabled = true;

        debugLog(
          `Tuned into broadcaster: ${broadcasterId} via broadcaster list`,
        );
      }

      // Initialize
      const audio = document.getElementById("audio-player");
      const sessionId = "{{ session_id }}";
      const player = new RadioPlayer(audio, sessionId);

      player.connectWebSocket();

      // UI Elements
      const tuneInBtn = document.getElementById("tune-in-btn");
      const tuneOutBtn = document.getElementById("tune-out-btn");
      const broadcastBtn = document.getElementById("broadcast-btn");
      const stopBroadcastBtn = document.getElementById("stop-broadcast-btn");
      const broadcasterInput = document.getElementById("broadcaster-input");
      const modeDisplay = document.getElementById("mode-display");
      const broadcastStatus = document.getElementById("broadcast-status");
      const broadcasterInfo = document.getElementById("broadcaster-info");
      const broadcasterName = document.getElementById("broadcaster-name");
      const prevBtn = document.getElementById("prev-btn");
      const nextBtn = document.getElementById("next-btn");

      tuneInBtn.addEventListener("click", () => {
        const broadcasterId = broadcasterInput.value.trim();
        if (!broadcasterId) {
          alert("Please enter a broadcaster session ID");
          return;
        }

        debugLog(`Tuning into broadcaster: ${broadcasterId}`);
        player.tuneIn(broadcasterId);

        modeDisplay.textContent = "Radio Mode";
        modeDisplay.className = "mode-badge radio";
        broadcasterName.textContent = broadcasterId;
        broadcasterInfo.classList.remove("hidden");

        tuneInBtn.classList.add("hidden");
        tuneOutBtn.classList.remove("hidden");

        prevBtn.disabled = true;
        nextBtn.disabled = true;
      });

      tuneOutBtn.addEventListener("click", () => {
        player.tuneOut();
      });

      broadcastBtn.addEventListener("click", () => {
        player.startBroadcasting();
      });

      stopBroadcastBtn.addEventListener("click", () => {
        player.stopBroadcasting();
      });

      document.body.addEventListener("htmx:afterSwap", function (event) {
        if (player.isInRadioMode()) return;

        if (event.detail.target.id === "player-controls") {
          const match = event.detail.target.textContent.match(/Track (\d+)/);
          if (!match) return;

          const newIndex = parseInt(match[1]) - 1;
          audio.src = `/player/stream/${newIndex}`;
          audio.load();
          audio.play();
        }
      });

      document.body.addEventListener("htmx:beforeRequest", function (event) {
        if (
          player.isInRadioMode() &&
          (event.detail.target.id === "prev-btn" ||
            event.detail.target.id === "next-btn")
        ) {
          event.preventDefault();
          alert("Controls disabled while tuned into a radio");
        }
      });

      audio.addEventListener("ended", () => {
        if (player.isInRadioMode()) {
          debugLog(
            "Track ended, but in radio mode ‚Äî waiting for broadcaster",
          );
          return;
        }

        debugLog("Track ended ‚Äî moving to next track");

        htmx.ajax("POST", "/player/next", {
          target: "#player-controls",
          swap: "innerHTML",
        });
      });

      window.addEventListener("beforeunload", () => {
        if (window.player) {
          window.player.disconnect();
        }
      });

      window.addEventListener("pagehide", () => {
        if (window.player) {
          debugLog("Page hide detected - cleaning up");
          if (window.player.isBroadcasting) {
            window.player.stopBroadcasting();
          }
          window.player.disconnect();
        }
      });

      // Make player globally accessible
      window.player = player;
    </script>
  </body>
</html>