<!doctype html>
<html>
  <head>
    <title>MP3 Player</title>
    <script src="https://unpkg.com/htmx.org@1.9.10"></script>
    <style>
      body {
        font-family: Arial, sans-serif;
        max-width: 800px;
        margin: 50px auto;
        padding: 20px;
      }

      #player-controls {
        background: #f0f0f0;
        padding: 20px;
        border-radius: 8px;
        margin-bottom: 20px;
      }

      .controls {
        display: flex;
        gap: 10px;
        margin-top: 20px;
      }

      button {
        padding: 10px 20px;
        font-size: 16px;
        cursor: pointer;
        border: none;
        background: #007bff;
        color: white;
        border-radius: 4px;
      }

      button:hover {
        background: #0056b3;
      }

      button:disabled {
        background: #6c757d;
        cursor: not-allowed;
      }

      audio {
        width: 100%;
        margin-top: 20px;
      }

      .song-info {
        font-size: 18px;
        margin-bottom: 10px;
      }

      /* Radio Mode Styles */
      .mode-container {
        background: #e9ecef;
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 20px;
      }

      .mode-indicator {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 10px;
      }

      .mode-badge {
        padding: 5px 12px;
        border-radius: 12px;
        font-weight: bold;
        font-size: 14px;
      }

      .mode-badge.private {
        background: #28a745;
        color: white;
      }

      .mode-badge.radio {
        background: #dc3545;
        color: white;
      }

      .mode-badge.broadcasting {
        background: #ffc107;
        color: black;
      }

      .radio-controls {
        display: grid;
        gap: 10px;
        margin-top: 15px;
      }

      .radio-input-group {
        display: flex;
        gap: 10px;
      }

      .radio-input-group input {
        flex: 1;
        padding: 8px;
        border: 1px solid #ced4da;
        border-radius: 4px;
        font-size: 14px;
      }

      .radio-input-group button {
        flex-shrink: 0;
      }

      .broadcaster-info {
        background: #fff;
        padding: 10px;
        border-radius: 4px;
        margin-top: 10px;
        font-size: 14px;
      }

      .session-id-display {
        background: #fff;
        padding: 10px;
        border-radius: 4px;
        margin-top: 10px;
        font-size: 14px;
        font-family: monospace;
      }

      .hidden {
        display: none;
      }

      #debug-log {
        background: #000;
        color: #0f0;
        padding: 10px;
        border-radius: 4px;
        margin-top: 20px;
        font-family: monospace;
        font-size: 12px;
        max-height: 200px;
        overflow-y: auto;
      }

      .analytics-container {
        background: #f8f9fa;
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 20px;
        border: 1px solid #dee2e6;
      }

      .analytics-container h3 {
        margin: 0 0 10px 0;
        font-size: 16px;
        color: #495057;
      }

      #analytics-display {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 15px;
      }

      .stat {
        background: white;
        padding: 10px;
        border-radius: 6px;
        text-align: center;
        border: 1px solid #e9ecef;
      }

      .stat-label {
        display: block;
        font-size: 12px;
        color: #6c757d;
        margin-bottom: 5px;
      }

      .stat-value {
        display: block;
        font-size: 24px;
        font-weight: bold;
        color: #007bff;
      }

      .broadcasters-container {
        background: #f8f9fa;
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 20px;
        border: 1px solid #dee2e6;
      }

      .broadcasters-container h3 {
        margin: 0 0 15px 0;
        font-size: 16px;
        color: #495057;
      }

      #broadcasters-list {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      .no-broadcasters {
        text-align: center;
        color: #6c757d;
        padding: 20px;
        font-style: italic;
      }

      .broadcaster-card {
        background: white;
        padding: 15px;
        border-radius: 6px;
        border: 1px solid #e9ecef;
        display: flex;
        align-items: center;
        justify-content: space-between;
        transition: box-shadow 0.2s;
      }

      .broadcaster-card:hover {
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }

      .broadcaster-info {
        flex: 1;
      }

      .broadcaster-id {
        font-size: 12px;
        color: #6c757d;
        font-family: monospace;
        margin-bottom: 5px;
      }

      .broadcaster-song {
        font-size: 14px;
        font-weight: 600;
        color: #212529;
        margin-bottom: 5px;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .play-status {
        font-size: 16px;
      }

      .broadcaster-time {
        font-size: 12px;
        color: #6c757d;
      }

      .tune-in-btn {
        padding: 8px 16px;
        font-size: 14px;
        background: #007bff;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        white-space: nowrap;
      }

      .tune-in-btn:hover {
        background: #0056b3;
      }

      .tune-in-btn:disabled {
        background: #6c757d;
        cursor: not-allowed;
      }

      .currently-tuned {
        background: #d4edda;
        border-color: #c3e6cb;
      }

      .self-broadcasting {
        background: #fff3cd;
        border-color: #ffeaa7;
      }
    </style>
  </head>
  <body>
    <h1>MP3 Player</h1>

    <div class="analytics-container">
      <h3>üìä Server Statistics (Live)</h3>
      <div id="analytics-display">
        <div class="stat">
          <span class="stat-label">Active Connections:</span>
          <span id="stat-connections" class="stat-value">0</span>
        </div>
        <div class="stat">
          <span class="stat-label">Broadcasting:</span>
          <span id="stat-broadcasters" class="stat-value">0</span>
        </div>
        <div class="stat">
          <span class="stat-label">Listening:</span>
          <span id="stat-listeners" class="stat-value">0</span>
        </div>
      </div>
    </div>

    <!-- Live Broadcasts -->
    <div class="broadcasters-container">
      <h3>üìª Live Broadcasts</h3>
      <div id="broadcasters-list">
        <div class="no-broadcasters">No one is broadcasting right now</div>
      </div>
    </div>

    <!-- Mode Indicator and Radio Controls -->
    <div class="mode-container">
      <div class="mode-indicator">
        <span id="mode-display" class="mode-badge private">Private Mode</span>
        <span id="broadcast-status" class="mode-badge broadcasting hidden"
          >Broadcasting</span
        >
      </div>

      <div class="session-id-display">
        <strong>Your Session ID:</strong>
        <span id="my-session-id">{{ session_id }}</span>
        <button
          onclick="copySessionId()"
          style="margin-left: 10px; padding: 5px 10px; font-size: 12px"
        >
          üìã Copy
        </button>
      </div>

      <div id="broadcaster-info" class="broadcaster-info hidden">
        Tuned into: <strong id="broadcaster-name"></strong>
      </div>

      <div class="radio-controls">
        <!-- Tune In -->
        <div class="radio-input-group">
          <input
            type="text"
            id="broadcaster-input"
            placeholder="Paste broadcaster's session ID here..."
            value=""
          />
          <button id="tune-in-btn">üìª Tune In</button>
          <button id="tune-out-btn" class="hidden">üè† Back to Private</button>
        </div>

        <!-- Broadcasting Controls -->
        <div class="radio-input-group">
          <button id="broadcast-btn">üì° Start Broadcasting</button>
          <button id="stop-broadcast-btn" class="hidden">
            ‚èπÔ∏è Stop Broadcasting
          </button>
        </div>
      </div>
    </div>

    <!-- Player Controls (existing) -->
    <div id="player-controls">
      <div class="song-info">
        <strong>Now Playing:</strong> {{ current_song }}
      </div>
      <div>Track {{ current_index + 1 }} of {{ total_songs }}</div>
    </div>

    <!-- Audio Player -->
    <audio id="audio-player" controls>
      <source src="/player/stream/{{ current_index }}" type="audio/mpeg" />
      Your browser doesn't support audio playback.
    </audio>

    <!-- Playback Controls -->
    <div class="controls">
      <button
        id="prev-btn"
        hx-post="/player/prev"
        hx-target="#player-controls"
        hx-swap="innerHTML"
      >
        ‚èÆÔ∏è Previous
      </button>

      <button
        id="next-btn"
        hx-post="/player/next"
        hx-target="#player-controls"
        hx-swap="innerHTML"
      >
        Next ‚è≠Ô∏è
      </button>
    </div>

    <!-- Debug Log -->
    <div id="debug-log"></div>

    <script>
      // Debug logging
      function debugLog(message) {
        const log = document.getElementById("debug-log");
        const time = new Date().toLocaleTimeString();
        log.innerHTML += `[${time}] ${message}<br>`;
        log.scrollTop = log.scrollHeight;
        console.log(message);
      }

      function copySessionId() {
        const sessionId = document.getElementById("my-session-id").textContent;
        navigator.clipboard.writeText(sessionId);
        //alert("Session ID copied!");
      }

      // Radio Player Class
      class RadioPlayer {
        constructor(audioElement, sessionId) {
          this.audio = audioElement;
          this.sessionId = sessionId;
          this.mode = "private";
          this.tunedBroadcaster = null;
          this.ws = null;
          this.heartbeatInterval = null;
          this.targetTime = 0;
          this.isBroadcasting = false;

          // Reconnection state
          this.reconnectAttempts = 0;
          this.maxReconnectAttempts = 10;
          this.baseReconnectDelay = 500;
          this.maxReconnectDelay = 30000;
          this.reconnectTimer = null;
          this.isIntentionalDisconnect = false;

          // Event listener tracking for cleanup
          this.boundHandlers = new Map(); // WebSocket handlers
          this.audioEventHandlers = new Map(); // Audio event handlers

          // Connection state for UI
          this.connectionState = "disconnected"; // 'disconnected', 'connecting', 'connected', 'error'

          debugLog(`Initialized with session ID: ${sessionId}`);
        }

        // Calculate exponential backoff with jitter
        getReconnectDelay() {
          const exponential =
            this.baseReconnectDelay * Math.pow(2, this.reconnectAttempts);
          const jitter = exponential * 0.2 * (Math.random() - 0.5);
          const delay = Math.min(
            Math.max(this.baseReconnectDelay, exponential + jitter),
            this.maxReconnectDelay,
          );
          return delay;
        }

        updateConnectionState(newState) {
          this.connectionState = newState;
          this.notifyConnectionChange(newState);
        }

        notifyConnectionChange(state) {
          const event = new CustomEvent("connectionStateChange", {
            detail: {
              state,
              attempt: this.reconnectAttempts,
              maxAttempts: this.maxReconnectAttempts,
            },
          });
          document.dispatchEvent(event);
        }

        connectWebSocket() {
          // Don't reconnect if already connected or connecting
          if (
            this.ws &&
            (this.ws.readyState === WebSocket.OPEN ||
              this.ws.readyState === WebSocket.CONNECTING)
          ) {
            debugLog(
              `WebSocket already ${this.ws.readyState === WebSocket.OPEN ? "connected" : "connecting"}, skipping...`,
            );
            return;
          }

          // Clear any pending reconnection timer
          if (this.reconnectTimer) {
            clearTimeout(this.reconnectTimer);
            this.reconnectTimer = null;
          }

          this.updateConnectionState("connecting");

          const protocol =
            window.location.protocol === "https:" ? "wss:" : "ws:";
          const wsUrl = `${protocol}//${window.location.host}/player/radio`;

          debugLog(
            `Connecting to WebSocket: ${wsUrl} (attempt ${this.reconnectAttempts + 1})`,
          );

          try {
            this.ws = new WebSocket(wsUrl);
          } catch (error) {
            debugLog(`Failed to create WebSocket: ${error.message}`);
            this.scheduleReconnect();
            return;
          }

          // Store bound handlers so we can remove them later
          const onOpen = () => {
            debugLog("‚úì WebSocket connected");
            this.reconnectAttempts = 0; // Reset on successful connection
            this.updateConnectionState("connected");

            // If we were broadcasting before disconnect, resume
            if (this.isBroadcasting) {
              debugLog("Resuming broadcast after reconnection");
              this.startBroadcasting();
            }

            // If we were tuned in, re-tune
            if (this.tunedBroadcaster) {
              debugLog(
                `Re-tuning to ${this.tunedBroadcaster} after reconnection`,
              );
              this.tuneIn(this.tunedBroadcaster);
            }
          };

          const onMessage = (event) => {
            debugLog(`‚Üê Received: ${event.data}`);
            try {
              const msg = JSON.parse(event.data);
              this.handleRadioMessage(msg);
            } catch (error) {
              debugLog(`Failed to parse message: ${error.message}`);
            }
          };

          const onError = (error) => {
            debugLog(`‚úó WebSocket error`);
            this.updateConnectionState("error");
          };

          const onClose = (event) => {
            debugLog(
              `WebSocket closed (code: ${event.code}, clean: ${event.wasClean})`,
            );
            this.updateConnectionState("disconnected");

            // Clean up existing handlers
            this.removeWebSocketHandlers();

            // Only attempt reconnection if it wasn't intentional
            if (!this.isIntentionalDisconnect) {
              this.scheduleReconnect();
            } else {
              debugLog("Intentional disconnect, not reconnecting");
              this.isIntentionalDisconnect = false;
            }
          };

          // Store handlers for cleanup
          this.boundHandlers.set("open", onOpen);
          this.boundHandlers.set("message", onMessage);
          this.boundHandlers.set("error", onError);
          this.boundHandlers.set("close", onClose);

          // Attach handlers
          this.ws.addEventListener("open", onOpen);
          this.ws.addEventListener("message", onMessage);
          this.ws.addEventListener("error", onError);
          this.ws.addEventListener("close", onClose);
        }

        scheduleReconnect() {
          if (this.reconnectAttempts >= this.maxReconnectAttempts) {
            debugLog(
              `Max reconnection attempts (${this.maxReconnectAttempts}) reached`,
            );
            this.updateConnectionState("error");
            alert(
              "Unable to connect to server after multiple attempts. Please refresh the page.",
            );
            return;
          }

          const delay = this.getReconnectDelay();
          debugLog(
            `Scheduling reconnection in ${delay}ms (attempt ${this.reconnectAttempts + 1}/${this.maxReconnectAttempts})`,
          );

          this.reconnectTimer = setTimeout(() => {
            this.reconnectAttempts++;
            this.connectWebSocket();
          }, delay);
        }

        removeWebSocketHandlers() {
          if (!this.ws) return;

          this.boundHandlers.forEach((handler, event) => {
            this.ws.removeEventListener(event, handler);
          });
          this.boundHandlers.clear();
        }

        disconnect() {
          this.isIntentionalDisconnect = true;

          // Clear reconnection timer
          if (this.reconnectTimer) {
            clearTimeout(this.reconnectTimer);
            this.reconnectTimer = null;
          }

          // Stop broadcasting if active
          if (this.isBroadcasting) {
            this.stopBroadcasting();
          }

          // Close WebSocket
          if (this.ws) {
            this.removeWebSocketHandlers();
            if (
              this.ws.readyState === WebSocket.OPEN ||
              this.ws.readyState === WebSocket.CONNECTING
            ) {
              this.ws.close();
            }
            this.ws = null;
          }

          this.updateConnectionState("disconnected");
          debugLog("Disconnected");
        }

        handleRadioMessage(msg) {
          if (msg.type === "Sync" && msg.broadcaster_id === this.sessionId) {
            return; // ignore own sync
          }

          debugLog(`Handling message type: ${msg.type}, mode: ${this.mode}`);

          // Handle analytics updates
          if (msg.type === "Analytics") {
            updateAnalyticsDisplay(msg);
            return;
          }

          // Handle error messages
          if (msg.type === "Error") {
            debugLog(`Server error: ${msg.message}`);
            alert(`Error: ${msg.message}`);
            return;
          }

          if (msg.type === "BroadcasterOffline") {
            if (this.tunedBroadcaster === msg.broadcaster_id) {
              debugLog(`Broadcaster ${msg.broadcaster_id} went offline`);
              alert(
                "The broadcaster you were listening to has stopped broadcasting.",
              );
              this.tuneOut("broadcaster_offline");
            }
            return;
          }

          if (msg.type === "BroadcasterOnline") {
            if (this.tunedBroadcaster === msg.broadcaster_id) {
              debugLog(`User ${msg.broadcaster_id} is now broadcasting`);
            }

            return;
          }

          if (this.mode !== "radio") return;

          switch (msg.type) {
            case "Sync":
              this.syncToBroadcaster(msg);
              break;
            case "Heartbeat":
              this.adjustForDrift(msg);
              break;
          }
        }

        syncToBroadcaster(msg) {
          const { song_index, playback_time, is_playing, server_timestamp_ms } =
            msg;

          const now = Date.now();
          const elapsed = (now - server_timestamp_ms) / 1000;

          // Account for time dilation between request and response
          this.targetTime = is_playing
            ? playback_time + elapsed
            : playback_time;

          const currentIndex = this.getCurrentSongIndex();

          if (currentIndex !== song_index) {
            debugLog(
              `Switching from song ${currentIndex} to song ${song_index}`,
            );
            this.audio.src = `/player/stream/${song_index}`;
            this.audio.load();

            htmx.ajax(
              "GET",
              `/player/controls?broadcaster=${this.tunedBroadcaster}`,
              { target: "#player-controls", swap: "innerHTML" },
            );
          }

          this.audio.currentTime = this.targetTime;

          if (is_playing && this.audio.paused) this.audio.play();
          if (!is_playing && !this.audio.paused) this.audio.pause();
        }

        adjustForDrift(msg) {
          if (this.audio.paused) return;

          const { playback_time, server_timestamp_ms } = msg;

          const now = Date.now();
          const elapsed = (now - server_timestamp_ms) / 1000;
          this.targetTime = playback_time + elapsed;

          const drift = Math.abs(this.audio.currentTime - this.targetTime);

          if (drift > 0.25) {
            debugLog(`Drift: ${drift.toFixed(3)}s - correcting`);
            this.audio.currentTime = this.targetTime;
          }
        }

        tuneIn(broadcasterId) {
          if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
            debugLog("WebSocket not ready, connecting...");
            this.connectWebSocket();
            setTimeout(() => this.tuneIn(broadcasterId), 500);
            return;
          }

          this.mode = "radio";
          this.tunedBroadcaster = broadcasterId;

          const msg = {
            type: "TuneIn",
            broadcaster_id: broadcasterId,
          };

          debugLog(`‚Üí Sending TuneIn: ${JSON.stringify(msg)}`);
          this.ws.send(JSON.stringify(msg));
        }

        tuneOut(reason = "manual") {
          debugLog(`Leaving radio mode: ${reason}`);

          if (this.ws && this.ws.readyState === WebSocket.OPEN) {
            this.ws.send(JSON.stringify({ type: "TuneOut" }));
          }

          this.mode = "private";
          this.tunedBroadcaster = null;

          // UI reset
          modeDisplay.textContent = "Private Mode";
          modeDisplay.className = "mode-badge private";
          broadcasterInfo.classList.add("hidden");

          tuneOutBtn.classList.add("hidden");
          tuneInBtn.classList.remove("hidden");

          prevBtn.disabled = false;
          nextBtn.disabled = false;
        }

        startBroadcasting() {
          if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
            debugLog("WebSocket not ready for broadcasting, connecting...");
            this.connectWebSocket();
            setTimeout(() => this.startBroadcasting(), 500);
            return;
          }

          // Clean up any existing broadcast FIRST
          this.stopBroadcasting();

          this.isBroadcasting = true;
          debugLog(`Broadcasting as: ${this.sessionId}`);

          const initBroadcast = () => {
            if (
              this.isBroadcasting &&
              this.ws &&
              this.ws.readyState === WebSocket.OPEN
            ) {
              const msg = {
                type: "StartBroadcasting",
                broadcaster_id: this.sessionId,
                song_index: this.getCurrentSongIndex(),
                playback_time: this.audio.currentTime,
                is_playing: !this.audio.paused,
              };
              debugLog(
                `‚Üí Broadcasting: song ${msg.song_index}, time ${msg.playback_time.toFixed(2)}s`,
              );
              this.ws.send(JSON.stringify(msg));
            }
          };

          const sendUpdate = () => {
            if (
              this.isBroadcasting &&
              this.ws &&
              this.ws.readyState === WebSocket.OPEN
            ) {
              const msg = {
                type: "BroadcastUpdate",
                broadcaster_id: this.sessionId,
                song_index: this.getCurrentSongIndex(),
                playback_time: this.audio.currentTime,
                is_playing: !this.audio.paused,
              };
              debugLog(
                `‚Üí Broadcasting: song ${msg.song_index}, time ${msg.playback_time.toFixed(2)}s`,
              );
              this.ws.send(JSON.stringify(msg));
            }
          };

          const sendHeartbeat = () => {
            if (
              this.isBroadcasting &&
              this.ws &&
              this.ws.readyState === WebSocket.OPEN
            ) {
              const msg = {
                type: "Heartbeat",
                broadcaster_id: this.sessionId,
                playback_time: this.audio.currentTime,
              };
              debugLog(
                `‚Üí Heartbeat: song ${this.getCurrentSongIndex()}, time ${msg.playback_time.toFixed(2)}s`,
              );
              this.ws.send(JSON.stringify(msg));
            }
          };

          // Store audio event handlers in separate map
          this.audioEventHandlers.set("play", sendUpdate);
          this.audioEventHandlers.set("pause", sendUpdate);
          this.audioEventHandlers.set("seeked", sendUpdate);

          // Attach ONLY these three events
          this.audio.addEventListener("play", sendUpdate);
          this.audio.addEventListener("pause", sendUpdate);
          this.audio.addEventListener("seeked", sendUpdate);

          audio.addEventListener("ended", () => {
            // Don't auto-skip if we're listening to a broadcaster
            if (player.isInRadioMode()) {
              debugLog(
                "Track ended, but in radio mode ‚Äî waiting for broadcaster",
              );
              return;
            }

            debugLog("Track ended ‚Äî moving to next track");

            // Trigger the same logic as clicking "Next"
            htmx.ajax("POST", "/player/next", {
              target: "#player-controls",
              swap: "innerHTML",
            });
          });

          this.heartbeatInterval = setInterval(sendHeartbeat, 2000);

          // Send initial state immediately
          initBroadcast();
        }

        stopBroadcasting() {
          this.isBroadcasting = false;

          if (this.heartbeatInterval) {
            clearInterval(this.heartbeatInterval);
            this.heartbeatInterval = null;
          }

          // Remove ONLY the audio listeners we attached
          this.audioEventHandlers.forEach((handler, event) => {
            this.audio.removeEventListener(event, handler);
          });
          this.audioEventHandlers.clear();

          if (this.ws && this.ws.readyState === WebSocket.OPEN) {
            this.ws.send(
              JSON.stringify({
                type: "StopBroadcasting",
                broadcaster_id: this.sessionId,
              }),
            );
          }

          debugLog("Broadcasting stopped");
        }

        getCurrentSongIndex() {
          const match = this.audio.src.match(/\/stream\/(\d+)/);
          return match ? parseInt(match[1]) : 0;
        }

        isInRadioMode() {
          return this.mode === "radio";
        }
      }

      // Update analytics display with live data
      function updateAnalyticsDisplay(analytics) {
        // Update stats
        document.getElementById("stat-connections").textContent =
          analytics.active_connections;
        document.getElementById("stat-broadcasters").textContent =
          analytics.active_broadcasters;
        document.getElementById("stat-listeners").textContent =
          analytics.active_listeners;

        // Update broadcasters list
        const broadcastersList = document.getElementById("broadcasters-list");

        if (analytics.broadcasters.length === 0) {
          broadcastersList.innerHTML =
            '<div class="no-broadcasters">No one is broadcasting right now</div>';
          return;
        }

        // Build broadcaster cards
        broadcastersList.innerHTML = analytics.broadcasters
          .map((broadcaster) => {
            const playIcon = broadcaster.is_playing ? "‚ñ∂Ô∏è" : "‚è∏Ô∏è";
            const minutes = Math.floor(broadcaster.playback_time / 60);
            const seconds = Math.floor(broadcaster.playback_time % 60);
            const timeStr = `${minutes}:${seconds.toString().padStart(2, "0")}`;

            // Check if this is the current user
            const isSelf = broadcaster.broadcaster_id === player.sessionId;

            // Check if we're currently tuned to this broadcaster
            const isTunedIn =
              player.tunedBroadcaster === broadcaster.broadcaster_id;

            // Determine card styling
            let cardClass = "broadcaster-card";
            if (isSelf) {
              cardClass += " self-broadcasting";
            } else if (isTunedIn) {
              cardClass += " currently-tuned";
            }

            // Determine button state
            let buttonHTML;
            if (isSelf) {
              buttonHTML = '<button class="tune-in-btn" disabled>You</button>';
            } else if (isTunedIn) {
              buttonHTML =
                '<button class="tune-in-btn" disabled>Tuned In ‚úì</button>';
            } else {
              buttonHTML = `<button class="tune-in-btn" onclick="tuneInToBroadcaster('${broadcaster.broadcaster_id}')">Tune In üìª</button>`;
            }

            return `
        <div class="${cardClass}">
          <div class="broadcaster-info">
            <div class="broadcaster-id">${broadcaster.broadcaster_id}</div>
            <div class="broadcaster-song">
              <span class="play-status">${playIcon}</span>
              <span>${broadcaster.song_name}</span>
            </div>
            <div class="broadcaster-time">
              Track ${broadcaster.song_index + 1} ‚Ä¢ ${timeStr}
            </div>
          </div>
          ${buttonHTML}
        </div>
      `;
          })
          .join("");
      }

      // Helper function to tune in from broadcaster list
      function tuneInToBroadcaster(broadcasterId) {
        document.getElementById("broadcaster-input").value = broadcasterId;

        player.tuneIn(broadcasterId);

        modeDisplay.textContent = "Radio Mode";
        modeDisplay.className = "mode-badge radio";
        broadcasterName.textContent = broadcasterId;
        broadcasterInfo.classList.remove("hidden");

        tuneInBtn.classList.add("hidden");
        tuneOutBtn.classList.remove("hidden");

        prevBtn.disabled = true;
        nextBtn.disabled = true;

        debugLog(
          `Tuned into broadcaster: ${broadcasterId} via broadcaster list`,
        );
      }

      // Initialize
      const audio = document.getElementById("audio-player");
      const sessionId = "{{ session_id }}";
      const player = new RadioPlayer(audio, sessionId);

      // Connect WebSocket
      player.connectWebSocket();

      // UI Elements
      const tuneInBtn = document.getElementById("tune-in-btn");
      const tuneOutBtn = document.getElementById("tune-out-btn");
      const broadcastBtn = document.getElementById("broadcast-btn");
      const stopBroadcastBtn = document.getElementById("stop-broadcast-btn");
      const broadcasterInput = document.getElementById("broadcaster-input");
      const modeDisplay = document.getElementById("mode-display");
      const broadcastStatus = document.getElementById("broadcast-status");
      const broadcasterInfo = document.getElementById("broadcaster-info");
      const broadcasterName = document.getElementById("broadcaster-name");
      const prevBtn = document.getElementById("prev-btn");
      const nextBtn = document.getElementById("next-btn");

      // Tune In
      tuneInBtn.addEventListener("click", () => {
        const broadcasterId = broadcasterInput.value.trim();
        if (!broadcasterId) {
          alert("Please enter a broadcaster session ID");
          return;
        }

        debugLog(`Tuning into broadcaster: ${broadcasterId}`);
        player.tuneIn(broadcasterId);

        modeDisplay.textContent = "Radio Mode";
        modeDisplay.className = "mode-badge radio";
        broadcasterName.textContent = broadcasterId;
        broadcasterInfo.classList.remove("hidden");

        tuneInBtn.classList.add("hidden");
        tuneOutBtn.classList.remove("hidden");

        prevBtn.disabled = true;
        nextBtn.disabled = true;
      });

      // Tune Out
      tuneOutBtn.addEventListener("click", () => {
        player.tuneOut();
      });

      // Start Broadcasting
      broadcastBtn.addEventListener("click", () => {
        player.startBroadcasting();

        broadcastStatus.classList.remove("hidden");
        broadcastBtn.classList.add("hidden");
        stopBroadcastBtn.classList.remove("hidden");
      });

      // Stop Broadcasting
      stopBroadcastBtn.addEventListener("click", () => {
        player.stopBroadcasting();

        broadcastStatus.classList.add("hidden");
        stopBroadcastBtn.classList.add("hidden");
        broadcastBtn.classList.remove("hidden");
      });

      // HTMX afterSwap handler (existing functionality)
      document.body.addEventListener("htmx:afterSwap", function (event) {
        if (player.isInRadioMode()) return;

        if (event.detail.target.id === "player-controls") {
          const match = event.detail.target.textContent.match(/Track (\d+)/);
          if (!match) return;

          const newIndex = parseInt(match[1]) - 1;
          audio.src = `/player/stream/${newIndex}`;
          audio.load();
          audio.play();
        }
      });

      // Prevent controls in radio mode
      document.body.addEventListener("htmx:beforeRequest", function (event) {
        if (
          player.isInRadioMode() &&
          (event.detail.target.id === "prev-btn" ||
            event.detail.target.id === "next-btn")
        ) {
          event.preventDefault();
          alert("Controls disabled while tuned into a radio");
        }
      });

      // Connection state indicator
      document.addEventListener("connectionStateChange", (event) => {
        const { state, attempt, maxAttempts } = event.detail;

        let statusText = "";
        let statusColor = "";

        switch (state) {
          case "connected":
            statusText = "üü¢ Connected";
            statusColor = "#28a745";
            break;
          case "connecting":
            statusText = `üü° Connecting${attempt > 0 ? ` (${attempt}/${maxAttempts})` : ""}...`;
            statusColor = "#ffc107";
            break;
          case "disconnected":
            statusText = "‚ö™ Disconnected";
            statusColor = "#6c757d";
            break;
          case "error":
            statusText = "üî¥ Connection Error";
            statusColor = "#dc3545";
            break;
        }

        debugLog(`Connection state: ${statusText}`);

        // You can update UI here with connection status
        // For example, add a status indicator element
      });

      // Clean up on page unload
      window.addEventListener("beforeunload", () => {
        if (window.player) {
          window.player.disconnect();
        }
      });
    </script>
  </body>
</html>
