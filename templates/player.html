<!doctype html>
<html>
  <head>
    <title>MP3 Player</title>
    <script src="https://unpkg.com/htmx.org@1.9.10"></script>
    <style>
      body {
        font-family: Arial, sans-serif;
        max-width: 800px;
        margin: 50px auto;
        padding: 20px;
      }

      #player-controls {
        background: #f0f0f0;
        padding: 20px;
        border-radius: 8px;
        margin-bottom: 20px;
      }

      .controls {
        display: flex;
        gap: 10px;
        margin-top: 20px;
      }

      button {
        padding: 10px 20px;
        font-size: 16px;
        cursor: pointer;
        border: none;
        background: #007bff;
        color: white;
        border-radius: 4px;
      }

      button:hover {
        background: #0056b3;
      }

      button:disabled {
        background: #6c757d;
        cursor: not-allowed;
      }

      audio {
        width: 100%;
        margin-top: 20px;
      }

      .song-info {
        font-size: 18px;
        margin-bottom: 10px;
      }

      /* Radio Mode Styles */
      .mode-container {
        background: #e9ecef;
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 20px;
      }

      .mode-indicator {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 10px;
      }

      .mode-badge {
        padding: 5px 12px;
        border-radius: 12px;
        font-weight: bold;
        font-size: 14px;
      }

      .mode-badge.private {
        background: #28a745;
        color: white;
      }

      .mode-badge.radio {
        background: #dc3545;
        color: white;
      }

      .mode-badge.broadcasting {
        background: #ffc107;
        color: black;
      }

      .radio-controls {
        display: grid;
        gap: 10px;
        margin-top: 15px;
      }

      .radio-input-group {
        display: flex;
        gap: 10px;
      }

      .radio-input-group input {
        flex: 1;
        padding: 8px;
        border: 1px solid #ced4da;
        border-radius: 4px;
        font-size: 14px;
      }

      .radio-input-group button {
        flex-shrink: 0;
      }

      .broadcaster-info {
        background: #fff;
        padding: 10px;
        border-radius: 4px;
        margin-top: 10px;
        font-size: 14px;
      }

      .session-id-display {
        background: #fff;
        padding: 10px;
        border-radius: 4px;
        margin-top: 10px;
        font-size: 14px;
        font-family: monospace;
      }

      .hidden {
        display: none;
      }

      #debug-log {
        background: #000;
        color: #0f0;
        padding: 10px;
        border-radius: 4px;
        margin-top: 20px;
        font-family: monospace;
        font-size: 12px;
        max-height: 200px;
        overflow-y: auto;
      }
    </style>
  </head>
  <body>
    <h1>MP3 Player</h1>

    <!-- Mode Indicator and Radio Controls -->
    <div class="mode-container">
      <div class="mode-indicator">
        <span id="mode-display" class="mode-badge private">Private Mode</span>
        <span id="broadcast-status" class="mode-badge broadcasting hidden"
          >Broadcasting</span
        >
      </div>

      <div class="session-id-display">
        <strong>Your Session ID:</strong>
        <span id="my-session-id">{{ session_id }}</span>
        <button
          onclick="copySessionId()"
          style="margin-left: 10px; padding: 5px 10px; font-size: 12px"
        >
          üìã Copy
        </button>
      </div>

      <div id="broadcaster-info" class="broadcaster-info hidden">
        Tuned into: <strong id="broadcaster-name"></strong>
      </div>

      <div class="radio-controls">
        <!-- Tune In -->
        <div class="radio-input-group">
          <input
            type="text"
            id="broadcaster-input"
            placeholder="Paste broadcaster's session ID here..."
            value=""
          />
          <button id="tune-in-btn">üìª Tune In</button>
          <button id="tune-out-btn" class="hidden">üè† Back to Private</button>
        </div>

        <!-- Broadcasting Controls -->
        <div class="radio-input-group">
          <button id="broadcast-btn">üì° Start Broadcasting</button>
          <button id="stop-broadcast-btn" class="hidden">
            ‚èπÔ∏è Stop Broadcasting
          </button>
        </div>
      </div>
    </div>

    <!-- Player Controls (existing) -->
    <div id="player-controls">
      <div class="song-info">
        <strong>Now Playing:</strong> {{ current_song }}
      </div>
      <div>Track {{ current_index + 1 }} of {{ total_songs }}</div>
    </div>

    <!-- Audio Player -->
    <audio id="audio-player" controls>
      <source src="/player/stream/{{ current_index }}" type="audio/mpeg" />
      Your browser doesn't support audio playback.
    </audio>

    <!-- Playback Controls -->
    <div class="controls">
      <button
        id="prev-btn"
        hx-post="/player/prev"
        hx-target="#player-controls"
        hx-swap="innerHTML"
      >
        ‚èÆÔ∏è Previous
      </button>

      <button
        id="next-btn"
        hx-post="/player/next"
        hx-target="#player-controls"
        hx-swap="innerHTML"
      >
        Next ‚è≠Ô∏è
      </button>
    </div>

    <!-- Debug Log -->
    <div id="debug-log"></div>

    <script>
      // Debug logging
      function debugLog(message) {
        const log = document.getElementById("debug-log");
        const time = new Date().toLocaleTimeString();
        log.innerHTML += `[${time}] ${message}<br>`;
        log.scrollTop = log.scrollHeight;
        console.log(message);
      }

      function copySessionId() {
        const sessionId = document.getElementById("my-session-id").textContent;
        navigator.clipboard.writeText(sessionId);
        //alert("Session ID copied!");
      }

      // Radio Player Class
      class RadioPlayer {
        constructor(audioElement, sessionId) {
          this.audio = audioElement;
          this.sessionId = sessionId;
          this.mode = "private";
          this.tunedBroadcaster = null;
          this.ws = null;
          this.heartbeatInterval = null;
          this.targetTime = 0;
          this.isBroadcasting = false;
          
          // Reconnection state
          this.reconnectAttempts = 0;
          this.maxReconnectAttempts = 10;
          this.baseReconnectDelay = 500;
          this.maxReconnectDelay = 30000;
          this.reconnectTimer = null;
          this.isIntentionalDisconnect = false;
          
          // Event listener tracking for cleanup
          this.boundHandlers = new Map();
          
          // Connection state for UI
          this.connectionState = 'disconnected'; // 'disconnected', 'connecting', 'connected', 'error'

          debugLog(`Initialized with session ID: ${sessionId}`);
        }
        
        // Calculate exponential backoff with jitter
        getReconnectDelay() {
          const exponential = this.baseReconnectDelay * Math.pow(2, this.reconnectAttempts);
          const jitter = exponential * 0.2 * (Math.random() - 0.5);
          const delay = Math.min(
            Math.max(this.baseReconnectDelay, exponential + jitter),
            this.maxReconnectDelay
          );
          return delay;
        }
        
        updateConnectionState(newState) {
          this.connectionState = newState;
          this.notifyConnectionChange(newState);
        }
        
        notifyConnectionChange(state) {
          const event = new CustomEvent('connectionStateChange', {
            detail: { 
              state, 
              attempt: this.reconnectAttempts,
              maxAttempts: this.maxReconnectAttempts
            }
          });
          document.dispatchEvent(event);
        }

        connectWebSocket() {
          // Don't reconnect if already connected or connecting
          if (this.ws && (this.ws.readyState === WebSocket.OPEN || this.ws.readyState === WebSocket.CONNECTING)) {
            debugLog(`WebSocket already ${this.ws.readyState === WebSocket.OPEN ? 'connected' : 'connecting'}, skipping...`);
            return;
          }
          
          // Clear any pending reconnection timer
          if (this.reconnectTimer) {
            clearTimeout(this.reconnectTimer);
            this.reconnectTimer = null;
          }
          
          this.updateConnectionState('connecting');

          const protocol =
            window.location.protocol === "https:" ? "wss:" : "ws:";
          const wsUrl = `${protocol}//${window.location.host}/player/radio`;

          debugLog(`Connecting to WebSocket: ${wsUrl} (attempt ${this.reconnectAttempts + 1})`);
          
          try {
            this.ws = new WebSocket(wsUrl);
          } catch (error) {
            debugLog(`Failed to create WebSocket: ${error.message}`);
            this.scheduleReconnect();
            return;
          }
          
          // Store bound handlers so we can remove them later
          const onOpen = () => {
            debugLog("‚úì WebSocket connected");
            this.reconnectAttempts = 0; // Reset on successful connection
            this.updateConnectionState('connected');
            
            // If we were broadcasting before disconnect, resume
            if (this.isBroadcasting) {
              debugLog("Resuming broadcast after reconnection");
              this.startBroadcasting();
            }
            
            // If we were tuned in, re-tune
            if (this.tunedBroadcaster) {
              debugLog(`Re-tuning to ${this.tunedBroadcaster} after reconnection`);
              this.tuneIn(this.tunedBroadcaster);
            }
          };
          
          const onMessage = (event) => {
            debugLog(`‚Üê Received: ${event.data}`);
            try {
              const msg = JSON.parse(event.data);
              this.handleRadioMessage(msg);
            } catch (error) {
              debugLog(`Failed to parse message: ${error.message}`);
            }
          };
          
          const onError = (error) => {
            debugLog(`‚úó WebSocket error`);
            this.updateConnectionState('error');
          };
          
          const onClose = (event) => {
            debugLog(`WebSocket closed (code: ${event.code}, clean: ${event.wasClean})`);
            this.updateConnectionState('disconnected');
            
            // Clean up existing handlers
            this.removeWebSocketHandlers();
            
            // Only attempt reconnection if it wasn't intentional
            if (!this.isIntentionalDisconnect) {
              this.scheduleReconnect();
            } else {
              debugLog("Intentional disconnect, not reconnecting");
              this.isIntentionalDisconnect = false;
            }
          };
          
          // Store handlers for cleanup
          this.boundHandlers.set('open', onOpen);
          this.boundHandlers.set('message', onMessage);
          this.boundHandlers.set('error', onError);
          this.boundHandlers.set('close', onClose);
          
          // Attach handlers
          this.ws.addEventListener('open', onOpen);
          this.ws.addEventListener('message', onMessage);
          this.ws.addEventListener('error', onError);
          this.ws.addEventListener('close', onClose);
        }
        
        scheduleReconnect() {
          if (this.reconnectAttempts >= this.maxReconnectAttempts) {
            debugLog(`Max reconnection attempts (${this.maxReconnectAttempts}) reached`);
            this.updateConnectionState('error');
            alert('Unable to connect to server after multiple attempts. Please refresh the page.');
            return;
          }
          
          const delay = this.getReconnectDelay();
          debugLog(`Scheduling reconnection in ${delay}ms (attempt ${this.reconnectAttempts + 1}/${this.maxReconnectAttempts})`);
          
          this.reconnectTimer = setTimeout(() => {
            this.reconnectAttempts++;
            this.connectWebSocket();
          }, delay);
        }
        
        removeWebSocketHandlers() {
          if (!this.ws) return;
          
          this.boundHandlers.forEach((handler, event) => {
            this.ws.removeEventListener(event, handler);
          });
          this.boundHandlers.clear();
        }
        
        disconnect() {
          this.isIntentionalDisconnect = true;
          
          // Clear reconnection timer
          if (this.reconnectTimer) {
            clearTimeout(this.reconnectTimer);
            this.reconnectTimer = null;
          }
          
          // Stop broadcasting if active
          if (this.isBroadcasting) {
            this.stopBroadcasting();
          }
          
          // Close WebSocket
          if (this.ws) {
            this.removeWebSocketHandlers();
            if (this.ws.readyState === WebSocket.OPEN || this.ws.readyState === WebSocket.CONNECTING) {
              this.ws.close();
            }
            this.ws = null;
          }
          
          this.updateConnectionState('disconnected');
          debugLog("Disconnected");
        }

        handleRadioMessage(msg) {
          if (msg.type === "Sync" && msg.broadcaster_id === this.sessionId) {
            return; // ignore own sync
          }

          debugLog(`Handling message type: ${msg.type}, mode: ${this.mode}`);
          
          // Handle error messages
          if (msg.type === "Error") {
            debugLog(`Server error: ${msg.message}`);
            alert(`Error: ${msg.message}`);
            return;
          }

          if (this.mode !== "radio") return;

          switch (msg.type) {
            case "Sync":
              this.syncToBroadcaster(msg);
              break;
            case "Heartbeat":
              this.adjustForDrift(msg);
              break;
          }
        }

        syncToBroadcaster(msg) {
          const { song_index, playback_time, is_playing, server_timestamp_ms } =
            msg;

          const now = Date.now();
          const elapsed = (now - server_timestamp_ms) / 1000;

          // Account for time dilation between request and response
          this.targetTime = is_playing
            ? playback_time + elapsed
            : playback_time;

          const currentIndex = this.getCurrentSongIndex();

          if (currentIndex !== song_index) {
            debugLog(
              `Switching from song ${currentIndex} to song ${song_index}`,
            );
            this.audio.src = `/player/stream/${song_index}`;
            this.audio.load();

            htmx.ajax(
              "GET",
              `/player/controls?broadcaster=${this.tunedBroadcaster}`,
              { target: "#player-controls", swap: "innerHTML" },
            );
          }

          this.audio.currentTime = this.targetTime;

          if (is_playing && this.audio.paused) this.audio.play();
          if (!is_playing && !this.audio.paused) this.audio.pause();
        }

        adjustForDrift(msg) {
          if (this.audio.paused) return;

          const { playback_time, server_timestamp_ms } = msg;

          const now = Date.now();
          const elapsed = (now - server_timestamp_ms) / 1000;
          this.targetTime = playback_time + elapsed;

          const drift = Math.abs(this.audio.currentTime - this.targetTime);

          if (drift > 0.25) {
            debugLog(`Drift: ${drift.toFixed(3)}s - correcting`);
            this.audio.currentTime = this.targetTime;
          }
        }

        tuneIn(broadcasterId) {
          if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
            debugLog("WebSocket not ready, connecting...");
            this.connectWebSocket();
            setTimeout(() => this.tuneIn(broadcasterId), 500);
            return;
          }

          this.mode = "radio";
          this.tunedBroadcaster = broadcasterId;

          const msg = {
            type: "TuneIn",
            broadcaster_id: broadcasterId,
          };

          debugLog(`‚Üí Sending TuneIn: ${JSON.stringify(msg)}`);
          this.ws.send(JSON.stringify(msg));
        }

        tuneOut(reason = "manual") {
          debugLog(`Leaving radio mode: ${reason}`);

          if (this.ws && this.ws.readyState === WebSocket.OPEN) {
            this.ws.send(JSON.stringify({ type: "TuneOut" }));
          }

          this.mode = "private";
          this.tunedBroadcaster = null;

          // UI reset
          modeDisplay.textContent = "Private Mode";
          modeDisplay.className = "mode-badge private";
          broadcasterInfo.classList.add("hidden");

          tuneOutBtn.classList.add("hidden");
          tuneInBtn.classList.remove("hidden");

          prevBtn.disabled = false;
          nextBtn.disabled = false;
        }

        startBroadcasting() {
          if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
            debugLog("WebSocket not ready for broadcasting, connecting...");
            this.connectWebSocket();
            setTimeout(() => this.startBroadcasting(), 500);
            return;
          }
          
          // Clean up any existing broadcast
          this.stopBroadcasting();

          this.isBroadcasting = true;
          debugLog(`Broadcasting as: ${this.sessionId}`);

          const sendUpdate = () => {
            if (this.isBroadcasting && this.ws && this.ws.readyState === WebSocket.OPEN) {
              const msg = {
                type: "BroadcastUpdate",
                broadcaster_id: this.sessionId,
                song_index: this.getCurrentSongIndex(),
                playback_time: this.audio.currentTime,
                is_playing: !this.audio.paused,
              };
              debugLog(
                `‚Üí Broadcasting: song ${msg.song_index}, time ${msg.playback_time.toFixed(2)}s`,
              );
              this.ws.send(JSON.stringify(msg));
            }
          };

          const sendHeartbeat = () => {
            if (this.isBroadcasting && this.ws && this.ws.readyState === WebSocket.OPEN) {
              const msg = {
                type: "Heartbeat",
                broadcaster_id: this.sessionId,
                playback_time: this.audio.currentTime,
              };
              debugLog(
                `‚Üí Heartbeat: song ${this.getCurrentSongIndex()}, time ${msg.playback_time.toFixed(2)}s`,
              );
              this.ws.send(JSON.stringify(msg));
            }
          };
          
          // Create bound handlers for cleanup
          this.boundHandlers.set('play', sendUpdate);
          this.boundHandlers.set('pause', sendUpdate);
          this.boundHandlers.set('seeked', sendUpdate);
          this.boundHandlers.set('waiting', sendUpdate);
          this.boundHandlers.set('playing', sendUpdate);
          
          // Attach audio event listeners
          this.boundHandlers.forEach((handler, event) => {
            if (['play', 'pause', 'seeked', 'waiting', 'playing'].includes(event)) {
              this.audio.addEventListener(event, handler);
            }
          });

          this.heartbeatInterval = setInterval(sendHeartbeat, 2000);

          // Send initial state immediately
          sendUpdate();
        }

        stopBroadcasting() {
          this.isBroadcasting = false;

          if (this.heartbeatInterval) {
            clearInterval(this.heartbeatInterval);
            this.heartbeatInterval = null;
          }
          
          // Remove audio event listeners
          ['play', 'pause', 'seeked', 'waiting', 'playing'].forEach(event => {
            const handler = this.boundHandlers.get(event);
            if (handler) {
              this.audio.removeEventListener(event, handler);
              this.boundHandlers.delete(event);
            }
          });

          debugLog("Broadcasting stopped");
        }

        getCurrentSongIndex() {
          const match = this.audio.src.match(/\/stream\/(\d+)/);
          return match ? parseInt(match[1]) : 0;
        }

        isInRadioMode() {
          return this.mode === "radio";
        }
      }

      // Initialize
      const audio = document.getElementById("audio-player");
      const sessionId = "{{ session_id }}";
      const player = new RadioPlayer(audio, sessionId);

      // Connect WebSocket
      player.connectWebSocket();

      // UI Elements
      const tuneInBtn = document.getElementById("tune-in-btn");
      const tuneOutBtn = document.getElementById("tune-out-btn");
      const broadcastBtn = document.getElementById("broadcast-btn");
      const stopBroadcastBtn = document.getElementById("stop-broadcast-btn");
      const broadcasterInput = document.getElementById("broadcaster-input");
      const modeDisplay = document.getElementById("mode-display");
      const broadcastStatus = document.getElementById("broadcast-status");
      const broadcasterInfo = document.getElementById("broadcaster-info");
      const broadcasterName = document.getElementById("broadcaster-name");
      const prevBtn = document.getElementById("prev-btn");
      const nextBtn = document.getElementById("next-btn");

      // Tune In
      tuneInBtn.addEventListener("click", () => {
        const broadcasterId = broadcasterInput.value.trim();
        if (!broadcasterId) {
          alert("Please enter a broadcaster session ID");
          return;
        }

        debugLog(`Tuning into broadcaster: ${broadcasterId}`);
        player.tuneIn(broadcasterId);

        modeDisplay.textContent = "Radio Mode";
        modeDisplay.className = "mode-badge radio";
        broadcasterName.textContent = broadcasterId;
        broadcasterInfo.classList.remove("hidden");

        tuneInBtn.classList.add("hidden");
        tuneOutBtn.classList.remove("hidden");

        prevBtn.disabled = true;
        nextBtn.disabled = true;
      });

      // Tune Out
      tuneOutBtn.addEventListener("click", () => {
        player.tuneOut();
      });

      // Start Broadcasting
      broadcastBtn.addEventListener("click", () => {
        player.startBroadcasting();

        broadcastStatus.classList.remove("hidden");
        broadcastBtn.classList.add("hidden");
        stopBroadcastBtn.classList.remove("hidden");
      });

      // Stop Broadcasting
      stopBroadcastBtn.addEventListener("click", () => {
        player.stopBroadcasting();

        broadcastStatus.classList.add("hidden");
        stopBroadcastBtn.classList.add("hidden");
        broadcastBtn.classList.remove("hidden");
      });

      // HTMX afterSwap handler (existing functionality)
      document.body.addEventListener("htmx:afterSwap", function (event) {
        if (player.isInRadioMode()) return;

        if (event.detail.target.id === "player-controls") {
          const match = event.detail.target.textContent.match(/Track (\d+)/);
          if (!match) return;

          const newIndex = parseInt(match[1]) - 1;
          audio.src = `/player/stream/${newIndex}`;
          audio.load();
          audio.play();
        }
      });

      // Prevent controls in radio mode
      document.body.addEventListener("htmx:beforeRequest", function (event) {
        if (
          player.isInRadioMode() &&
          (event.detail.target.id === "prev-btn" ||
            event.detail.target.id === "next-btn")
        ) {
          event.preventDefault();
          alert("Controls disabled while tuned into a radio");
        }
      });
      
      // Connection state indicator
      document.addEventListener('connectionStateChange', (event) => {
        const { state, attempt, maxAttempts } = event.detail;
        
        let statusText = '';
        let statusColor = '';
        
        switch (state) {
          case 'connected':
            statusText = 'üü¢ Connected';
            statusColor = '#28a745';
            break;
          case 'connecting':
            statusText = `üü° Connecting${attempt > 0 ? ` (${attempt}/${maxAttempts})` : ''}...`;
            statusColor = '#ffc107';
            break;
          case 'disconnected':
            statusText = '‚ö™ Disconnected';
            statusColor = '#6c757d';
            break;
          case 'error':
            statusText = 'üî¥ Connection Error';
            statusColor = '#dc3545';
            break;
        }
        
        debugLog(`Connection state: ${statusText}`);
        
        // You can update UI here with connection status
        // For example, add a status indicator element
      });

      // Clean up on page unload
      window.addEventListener('beforeunload', () => {
        if (window.player) {
          window.player.disconnect();
        }
      });
    </script>
  </body>
</html>