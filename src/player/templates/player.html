<!doctype html>
<html>
  <head>
    <title>MP3 Player</title>
    <script src="https://unpkg.com/htmx.org@1.9.10"></script>
    <style>
      body {
        font-family: Arial, sans-serif;
        max-width: 800px;
        margin: 50px auto;
        padding: 20px;
      }

      #player-controls {
        background: #f0f0f0;
        padding: 20px;
        border-radius: 8px;
        margin-bottom: 20px;
      }

      .controls {
        display: flex;
        gap: 10px;
        margin-top: 20px;
      }

      button {
        padding: 10px 20px;
        font-size: 16px;
        cursor: pointer;
        border: none;
        background: #007bff;
        color: white;
        border-radius: 4px;
      }

      button:hover {
        background: #0056b3;
      }

      button:disabled {
        background: #6c757d;
        cursor: not-allowed;
      }

      audio {
        width: 100%;
        margin-top: 20px;
      }

      .song-info {
        font-size: 18px;
        margin-bottom: 10px;
      }

      /* Radio Mode Styles */
      .mode-container {
        background: #e9ecef;
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 20px;
      }

      .mode-indicator {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 10px;
      }

      .mode-badge {
        padding: 5px 12px;
        border-radius: 12px;
        font-weight: bold;
        font-size: 14px;
      }

      .mode-badge.private {
        background: #28a745;
        color: white;
      }

      .mode-badge.radio {
        background: #dc3545;
        color: white;
      }

      .mode-badge.broadcasting {
        background: #ffc107;
        color: black;
      }

      .radio-controls {
        display: grid;
        gap: 10px;
        margin-top: 15px;
      }

      .radio-input-group {
        display: flex;
        gap: 10px;
      }

      .radio-input-group input {
        flex: 1;
        padding: 8px;
        border: 1px solid #ced4da;
        border-radius: 4px;
        font-size: 14px;
      }

      .radio-input-group button {
        flex-shrink: 0;
      }

      .broadcaster-info {
        background: #fff;
        padding: 10px;
        border-radius: 4px;
        margin-top: 10px;
        font-size: 14px;
      }

      .session-id-display {
        background: #fff;
        padding: 10px;
        border-radius: 4px;
        margin-top: 10px;
        font-size: 14px;
        font-family: monospace;
      }

      .hidden {
        display: none;
      }

      #debug-log {
        background: #000;
        color: #0f0;
        padding: 10px;
        border-radius: 4px;
        margin-top: 20px;
        font-family: monospace;
        font-size: 12px;
        max-height: 200px;
        overflow-y: auto;
      }

      .analytics-container {
        background: #f8f9fa;
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 20px;
        border: 1px solid #dee2e6;
      }

      .analytics-container h3 {
        margin: 0 0 10px 0;
        font-size: 16px;
        color: #495057;
      }

      #analytics-display {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 15px;
      }

      .stat {
        background: white;
        padding: 10px;
        border-radius: 6px;
        text-align: center;
        border: 1px solid #e9ecef;
      }

      .stat-label {
        display: block;
        font-size: 12px;
        color: #6c757d;
        margin-bottom: 5px;
      }

      .stat-value {
        display: block;
        font-size: 24px;
        font-weight: bold;
        color: #007bff;
      }

      .broadcasters-container {
        background: #f8f9fa;
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 20px;
        border: 1px solid #dee2e6;
      }

      .broadcasters-container h3 {
        margin: 0 0 15px 0;
        font-size: 16px;
        color: #495057;
      }

      #broadcasters-list {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      .no-broadcasters {
        text-align: center;
        color: #6c757d;
        padding: 20px;
        font-style: italic;
      }

      .broadcaster-card {
        background: white;
        padding: 15px;
        border-radius: 6px;
        border: 1px solid #e9ecef;
        display: flex;
        align-items: center;
        justify-content: space-between;
        transition: box-shadow 0.2s;
      }

      .broadcaster-card:hover {
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }

      .broadcaster-info-card {
        flex: 1;
      }

      .broadcaster-id {
        font-size: 12px;
        color: #6c757d;
        font-family: monospace;
        margin-bottom: 5px;
      }

      .broadcaster-song {
        font-size: 14px;
        font-weight: 600;
        color: #212529;
        margin-bottom: 5px;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .play-status {
        font-size: 16px;
      }

      .broadcaster-time {
        font-size: 12px;
        color: #6c757d;
      }

      .tune-in-btn {
        padding: 8px 16px;
        font-size: 14px;
        background: #007bff;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        white-space: nowrap;
      }

      .tune-in-btn:hover {
        background: #0056b3;
      }

      .tune-in-btn:disabled {
        background: #6c757d;
        cursor: not-allowed;
      }

      .currently-tuned {
        background: #d4edda;
        border-color: #c3e6cb;
      }

      .self-broadcasting {
        background: #fff3cd;
        border-color: #ffeaa7;
      }

      .mobile-warning {
        background: #fff3cd;
        border: 1px solid #ffc107;
        padding: 10px;
        border-radius: 4px;
        margin-bottom: 10px;
        font-size: 14px;
      }

      .connection-status {
        background: #fff;
        padding: 8px 12px;
        border-radius: 4px;
        margin-top: 10px;
        font-size: 13px;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      #connection-text {
        font-weight: 500;
      }

      /* Playlist Styles */
      .playlist-container {
        background: #f8f9fa;
        padding: 15px;
        border-radius: 8px;
        margin-top: 20px;
        margin-bottom: 20px;
        border: 1px solid #dee2e6;
      }

      .playlist-container h3 {
        margin: 0 0 10px 0;
        font-size: 16px;
        color: #495057;
      }

      .playlist-controls {
        margin-bottom: 10px;
      }

      /* Scrollable playlist container */
      #playlist-display {
        max-height: 400px;
        overflow-y: auto;
        overflow-x: hidden;
      }

      .playlist-item {
        background: white;
        padding: 12px;
        margin-bottom: 8px;
        border-radius: 4px;
        border: 1px solid #e9ecef;
        cursor: default;
        display: flex;
        align-items: center;
        gap: 10px;
        transition: all 0.2s;
        /* Allow normal page scrolling everywhere on the row except the handle */
        touch-action: pan-y;
      }

      .playlist-item:hover {
        background: #f8f9fa;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      .playlist-item.dragging {
        opacity: 0.5;
      }

      .playlist-item.current-playing {
        background: #e7f3ff;
        border-color: #007bff;
        font-weight: 600;
      }

      .drag-handle {
        font-size: 18px;
        cursor: grab;
        color: #6c757d;
        /* Only the handle suppresses scroll ‚Äî the rest of the row stays scrollable */
        touch-action: none;
        user-select: none;
        padding: 4px 2px; /* slightly larger hit area on mobile */
      }

      .drag-handle:active {
        cursor: grabbing;
      }

      .song-number {
        font-weight: bold;
        color: #6c757d;
        min-width: 30px;
        font-size: 14px;
      }

      .song-name {
        flex: 1;
        font-size: 14px;
        color: #212529;
        /* min-width: 0 lets flex children shrink below their content size ‚Äî
           without this the text pushes the Play button off-screen */
        min-width: 0;
        overflow: hidden;
        white-space: nowrap;
        text-overflow: ellipsis;
        cursor: default;
      }

      /* The inner span is what actually scrolls on hover */
      .song-name .song-text {
        display: inline-block;
      }

      @keyframes song-marquee {
        0%, 15%  { transform: translateX(0); }
        85%, 100% { transform: translateX(var(--scroll-dist, 0px)); }
      }

      .play-song-btn {
        padding: 6px 12px;
        font-size: 12px;
        background: #28a745;
        border: none;
        color: white;
        border-radius: 4px;
        cursor: pointer;
      }

      .play-song-btn:hover {
        background: #218838;
      }

      .play-song-btn:disabled {
        background: #6c757d;
        cursor: not-allowed;
      }

      .loading {
        text-align: center;
        color: #6c757d;
        padding: 20px;
        font-style: italic;
      }
    </style>
  </head>
  <body>
    <h1>MP3 Player</h1>

    <div class="analytics-container">
      <h3>üìä Server Statistics (Live)</h3>
      <div id="analytics-display">
        <div class="stat">
          <span class="stat-label">Active Connections:</span>
          <span id="stat-connections" class="stat-value">0</span>
        </div>
        <div class="stat">
          <span class="stat-label">Broadcasting:</span>
          <span id="stat-broadcasters" class="stat-value">0</span>
        </div>
        <div class="stat">
          <span class="stat-label">Listening:</span>
          <span id="stat-listeners" class="stat-value">0</span>
        </div>
      </div>
    </div>

    <!-- Live Broadcasts -->
    <div class="broadcasters-container">
      <h3>üìª Live Broadcasts</h3>
      <div id="broadcasters-list">
        <div class="no-broadcasters">No one is broadcasting right now</div>
      </div>
    </div>

    <!-- Mobile Warning -->
    <div id="mobile-warning" class="mobile-warning hidden">
      ‚ö†Ô∏è Broadcasting on mobile may stop when the screen locks or you switch apps. 
      Keep this tab active for best results.
    </div>

    <!-- Mode Indicator and Radio Controls -->
    <div class="mode-container">
      <div class="mode-indicator">
        <span id="mode-display" class="mode-badge private">Private Mode</span>
        <span id="broadcast-status" class="mode-badge broadcasting hidden"
          >Broadcasting</span
        >
      </div>

      <div class="connection-status">
        <span id="connection-indicator">üü°</span>
        <span id="connection-text">Connecting...</span>
      </div>

      <div class="session-id-display">
        <strong>Your Session ID:</strong>
        <span id="my-session-id">{{ session_id }}</span>
        <button
          onclick="copySessionId()"
          style="margin-left: 10px; padding: 5px 10px; font-size: 12px"
        >
          üìã Copy
        </button>
      </div>

      <div id="broadcaster-info" class="broadcaster-info hidden">
        Tuned into: <strong id="broadcaster-name"></strong>
      </div>

      <div class="radio-controls">
        <!-- Tune In -->
        <div class="radio-input-group">
          <input
            type="text"
            id="broadcaster-input"
            placeholder="Paste broadcaster's session ID here..."
            value=""
          />
          <button id="tune-in-btn">üìª Tune In</button>
          <button id="tune-out-btn" class="hidden">üè† Back to Private</button>
        </div>

        <!-- Broadcasting Controls -->
        <div class="radio-input-group">
          <button id="broadcast-btn">üì° Start Broadcasting</button>
          <button id="stop-broadcast-btn" class="hidden">
            ‚èπÔ∏è Stop Broadcasting
          </button>
        </div>
      </div>
    </div>

    <!-- Player Controls (existing) -->
    <div id="player-controls">
      <div class="song-info">
        <strong>You Are Now Playing:</strong> {{ current_song }}
      </div>
      <div>Track {{ current_index + 1 }} of {{ total_songs }}</div>
    </div>

    <!-- Audio Player -->
    <audio id="audio-player" controls>
      <source src="/player/stream/{{ current_index }}" type="audio/mpeg" />
      Your browser doesn't support audio playback.
    </audio>

    <!-- Playback Controls -->
    <div class="controls">
      <button id="prev-btn">‚èÆÔ∏è Previous</button>
      <button id="next-btn">Next ‚è≠Ô∏è</button>
    </div>
    
    <!-- Playlist Display -->
    <div class="playlist-container">
      <h3>üìú Your Playlist</h3>
      <div class="playlist-controls">
        <button onclick="resetPlaylistOrder()" style="font-size: 14px; padding: 8px 12px;">
          üîÑ Reset to Default Order
        </button>
      </div>
      <div id="playlist-display">
        <div class="loading">Loading playlist...</div>
      </div>
    </div>

    <!-- Debug Log -->
    <div id="debug-log"></div>

    <script>
      // Debug logging
      function debugLog(message) {
        const log = document.getElementById("debug-log");
        const time = new Date().toLocaleTimeString();
        log.innerHTML += `[${time}] ${message}<br>`;
        log.scrollTop = log.scrollHeight;
        console.log(message);
      }

      function copySessionId() {
        const sessionId = document.getElementById("my-session-id").textContent;
        navigator.clipboard.writeText(sessionId);
        debugLog("Session ID copied to clipboard");
      }

      // Playlist Management Class
      class PlaylistManager {
        constructor(sessionId) {
          this.sessionId = sessionId;
          this.songs = [];
          // Preserves the original server order so we can look up the correct
          // numeric index to broadcast ‚Äî the server's /stream/{index} endpoints
          // use this order, not the user's custom order
          this.originalSongs = [];
          this.currentSongId = null;
          this.storageKey = `playlist_order_${sessionId}`;
        }

        async loadPlaylist() {
          try {
            debugLog("Fetching playlist from server...");
            const response = await fetch('/player/playlist');
            const serverSongs = await response.json();
            // Store original server order before any custom reordering
            this.originalSongs = serverSongs;
            this.songs = [...serverSongs];
            debugLog(`Loaded ${this.songs.length} songs`);

            // Load custom order from localStorage
            this.loadCustomOrder();

            // Sync currentSongId from whatever is actually playing right now.
            // This handles page load where audio src is set server-side and the
            // playlist manager doesn't know about it yet.
            this.syncCurrentFromAudio();

            // Display the playlist
            this.render();
          } catch (err) {
            debugLog(`Failed to load playlist: ${err.message}`);
          }
        }

        // Sets currentSongId by reading the audio element's current src.
        // Must be called after originalSongs is populated so index lookups work.
        syncCurrentFromAudio() {
          // audio.src returns "" when src is set via a <source> child element
          // rather than directly on the <audio> tag (as on initial page load).
          // audio.currentSrc is what the browser actually resolved, but may also
          // be "" before the user interacts. Reading the <source> attribute
          // directly is the reliable fallback for the initial render.
          const srcToCheck = audio.currentSrc
            || audio.src
            || audio.querySelector('source')?.getAttribute('src')
            || '';

          const idMatch = srcToCheck.match(/\/stream\/id\/([^/?]+)/);
          const indexMatch = srcToCheck.match(/\/stream\/(\d+)(?:[^/]|$)/);

          if (idMatch) {
            this.currentSongId = idMatch[1];
            debugLog(`Synced current song from audio src (id): ${this.currentSongId}`);
          } else if (indexMatch) {
            const index = parseInt(indexMatch[1]);
            const song = this.originalSongs[index];
            if (song) {
              this.currentSongId = song.id;
              debugLog(`Synced current song from audio src (index ${index}): ${song.filename}`);
            }
          }
        }

        loadCustomOrder() {
          const savedOrder = localStorage.getItem(this.storageKey);
          if (!savedOrder) {
            debugLog("No custom playlist order found, using default");
            return;
          }

          try {
            const orderIds = JSON.parse(savedOrder);
            
            // Validate that all IDs still exist
            const validIds = orderIds.filter(id => 
              this.songs.some(song => song.id === id)
            );

            // Reorder songs array based on saved order
            const orderedSongs = [];
            validIds.forEach(id => {
              const song = this.songs.find(s => s.id === id);
              if (song) orderedSongs.push(song);
            });

            // Add any new songs that weren't in the saved order
            this.songs.forEach(song => {
              if (!validIds.includes(song.id)) {
                orderedSongs.push(song);
              }
            });

            this.songs = orderedSongs;
            debugLog("Loaded custom playlist order from localStorage");
          } catch (err) {
            debugLog(`Failed to parse saved order: ${err.message}`);
          }
        }

        saveCustomOrder() {
          const orderIds = this.songs.map(song => song.id);
          localStorage.setItem(this.storageKey, JSON.stringify(orderIds));
          debugLog("Saved custom playlist order to localStorage");
        }

        resetToDefaultOrder() {
          localStorage.removeItem(this.storageKey);
          debugLog("Reset to default playlist order");
          this.loadPlaylist();
        }

        // Returns the server's numeric index for a given song ID.
        // This is what the broadcast protocol uses ‚Äî it must match the
        // original unshuffled server order, not the user's custom order.
        getServerIndexById(songId) {
          const index = this.originalSongs.findIndex(s => s.id === songId);
          // Fall back to 0 if not found to avoid sending garbage
          return index >= 0 ? index : 0;
        }

        // Returns the song ID for a given server numeric index
        getSongIdByServerIndex(index) {
          if (this.originalSongs[index]) {
            return this.originalSongs[index].id;
          }
          return null;
        }

        render(skipScroll = false) {
          const container = document.getElementById('playlist-display');
          
          if (this.songs.length === 0) {
            container.innerHTML = '<div class="loading">No songs found</div>';
            return;
          }

          container.innerHTML = this.songs.map((song, index) => {
            const isPlaying = song.id === this.currentSongId;
            const playingClass = isPlaying ? 'current-playing' : '';
            const playBtnText = isPlaying ? '‚è∏Ô∏è Playing' : '‚ñ∂Ô∏è Play';
            
            return `
              <div class="playlist-item ${playingClass}" 
                   draggable="true" 
                   data-song-id="${song.id}"
                   data-index="${index}">
                <span class="drag-handle">‚ãÆ‚ãÆ</span>
                <span class="song-number">${index + 1}.</span>
                <span class="song-name"><span class="song-text">${song.filename}</span></span>
                <button class="play-song-btn" 
                        onclick="playlistManager.playSong('${song.id}')"
                        ${player.isInRadioMode() ? 'disabled' : ''}>
                  ${playBtnText}
                </button>
              </div>
            `;
          }).join('');

          this.setupDragAndDrop();
          if (!skipScroll) this.scrollToCurrentSong();
        }

        setupDragAndDrop() {
          const items = document.querySelectorAll('.playlist-item');
          items.forEach(item => {
            // Desktop: HTML5 drag events on the whole row (unchanged)
            item.addEventListener('dragstart', this.handleDragStart.bind(this));
            item.addEventListener('dragover', this.handleDragOver.bind(this));
            item.addEventListener('drop', this.handleDrop.bind(this));
            item.addEventListener('dragend', this.handleDragEnd.bind(this));
          });

          // Marquee: scroll overflowing song names on hover so full title is readable.
          // Measures actual overflow so the animation travels exactly the right distance.
          document.querySelectorAll('.song-name').forEach(el => {
            const span = el.querySelector('.song-text');
            if (!span) return;
            el.addEventListener('mouseenter', () => {
              const overflow = span.scrollWidth - el.clientWidth;
              if (overflow <= 0) return; // text fits ‚Äî nothing to scroll
              const duration = Math.max(2, overflow / 40); // ~40px/s feels natural
              span.style.setProperty('--scroll-dist', `-${overflow}px`);
              span.style.animation = `song-marquee ${duration}s ease-in-out infinite`;
            });
            el.addEventListener('mouseleave', () => {
              span.style.animation = '';
              span.style.transform = '';
            });
          });

          // Mobile: touch events only on the ‚ãÆ‚ãÆ handle so the rest of the
          // row remains scrollable on phones
          document.querySelectorAll('.drag-handle').forEach(handle => {
            handle.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: false });
            handle.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false });
            handle.addEventListener('touchend', this.handleTouchEnd.bind(this), { passive: true });
            // touchcancel fires when the browser interrupts the gesture (incoming
            // call, scroll takeover, etc.) ‚Äî without this the clone stays on screen
            handle.addEventListener('touchcancel', this.handleTouchCancel.bind(this), { passive: true });
          });
        }

        // ‚îÄ‚îÄ Desktop drag handlers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

        handleDragStart(e) {
          this.draggedElement = e.currentTarget;
          e.currentTarget.classList.add('dragging');
          e.dataTransfer.effectAllowed = 'move';
          e.dataTransfer.setData('text/html', e.currentTarget.innerHTML);
        }

        handleDragOver(e) {
          e.preventDefault();
          e.dataTransfer.dropEffect = 'move';
          return false;
        }

        handleDrop(e) {
          e.stopPropagation();
          const draggedIndex = parseInt(this.draggedElement.dataset.index);
          const targetIndex = parseInt(e.currentTarget.dataset.index);
          if (draggedIndex !== targetIndex) {
            const draggedSong = this.songs[draggedIndex];
            this.songs.splice(draggedIndex, 1);
            this.songs.splice(targetIndex, 0, draggedSong);
            this.saveCustomOrder();
            this.render(true); // don't scroll ‚Äî user is looking at the drag target area
            debugLog(`Moved song from position ${draggedIndex + 1} to ${targetIndex + 1}`);
          }
          return false;
        }

        handleDragEnd(e) {
          e.currentTarget.classList.remove('dragging');
          this.draggedElement = null;
        }

        // ‚îÄ‚îÄ Mobile touch handlers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

        handleTouchStart(e) {
          // e.currentTarget is the ‚ãÆ‚ãÆ handle ‚Äî walk up to the row
          const row = e.currentTarget.closest('.playlist-item');
          if (!row) return;

          e.preventDefault(); // prevent scroll starting from the handle

          this.touchDragElement = row;
          this.touchDragStartIndex = parseInt(row.dataset.index);
          this.touchDragCurrentIndex = this.touchDragStartIndex;

          const touch = e.touches[0];
          this.touchLastY = touch.clientY;

          // Record where inside the row the finger landed so the clone
          // appears anchored under the finger, not jumping to the row's top edge
          const rect = row.getBoundingClientRect();
          this.touchGrabOffsetY = touch.clientY - rect.top;

          // Floating clone follows the finger
          this.touchClone = row.cloneNode(true);
          this.touchClone.style.cssText = `
            position: fixed;
            left: ${rect.left}px;
            top: ${touch.clientY - this.touchGrabOffsetY}px;
            width: ${rect.width}px;
            opacity: 0.85;
            pointer-events: none;
            z-index: 9999;
            box-shadow: 0 4px 16px rgba(0,0,0,0.25);
            border-radius: 4px;
            background: #e7f3ff;
            border: 1px solid #007bff;
          `;
          document.body.appendChild(this.touchClone);

          row.classList.add('dragging');
          this.touchDragActive = true;

          // Haptic feedback on grab (supported on Android Chrome)
          if (navigator.vibrate) navigator.vibrate(30);
        }

        handleTouchMove(e) {
          if (!this.touchDragActive) return;
          e.preventDefault(); // stop page scroll while dragging

          const touch = e.touches[0];
          this.touchLastY = touch.clientY;

          // Position clone so the grab point stays under the finger
          this.touchClone.style.top = `${touch.clientY - this.touchGrabOffsetY}px`;

          // Auto-scroll the playlist container when the finger is near its edges.
          const container = document.getElementById('playlist-display');
          const cRect = container.getBoundingClientRect();
          const edgeZone = 60; // px from top/bottom edge that triggers scroll
          const scrollSpeed = 8; // px scrolled per touchmove tick
          if (touch.clientY < cRect.top + edgeZone) {
            container.scrollTop -= scrollSpeed;
          } else if (touch.clientY > cRect.bottom - edgeZone) {
            container.scrollTop += scrollSpeed;
          }

          // Find which playlist item the finger is currently over
          this.touchClone.style.display = 'none'; // hide clone so elementFromPoint works
          const target = document.elementFromPoint(touch.clientX, touch.clientY);
          this.touchClone.style.display = '';

          const targetItem = target?.closest('.playlist-item');
          if (!targetItem) return;

          const targetIndex = parseInt(targetItem.dataset.index);
          if (isNaN(targetIndex) || targetIndex === this.touchDragCurrentIndex) return;

          // Midpoint guard: only swap once the clone's leading edge has crossed
          // past the midpoint of the target row, preventing jittery back-and-forth
          // when hovering near a row boundary.
          const targetRect = targetItem.getBoundingClientRect();
          const targetMid = targetRect.top + targetRect.height / 2;
          const movingDown = targetIndex > this.touchDragCurrentIndex;
          if (movingDown && touch.clientY < targetMid) return;
          if (!movingDown && touch.clientY > targetMid) return;

          // Reorder data array live for immediate visual feedback
          const draggedSong = this.songs[this.touchDragCurrentIndex];
          this.songs.splice(this.touchDragCurrentIndex, 1);
          this.songs.splice(targetIndex, 0, draggedSong);
          this.touchDragCurrentIndex = targetIndex;

          // Haptic feedback on each reorder step
          if (navigator.vibrate) navigator.vibrate(15);

          // Lightweight re-render that keeps drag state intact
          this.renderForDrag(targetIndex);
        }

        handleTouchEnd(e) {
          if (!this.touchDragActive) return;
          this.touchDragActive = false;

          if (this.touchClone) {
            this.touchClone.remove();
            this.touchClone = null;
          }

          document.querySelectorAll('.playlist-item.dragging').forEach(el => {
            el.classList.remove('dragging');
          });

          if (this.touchDragCurrentIndex !== this.touchDragStartIndex) {
            this.saveCustomOrder();
            debugLog(`Moved song from position ${this.touchDragStartIndex + 1} to ${this.touchDragCurrentIndex + 1}`);
          }

          this.render(true); // don't scroll ‚Äî user is looking at the drag target area
        }

        // Fires when the browser cancels the touch gesture (e.g. incoming call,
        // system scroll takeover). Cleans up exactly like touchend but without
        // saving the order ‚Äî the drag was interrupted, treat it as a no-op.
        handleTouchCancel(e) {
          if (!this.touchDragActive) return;
          this.touchDragActive = false;

          if (this.touchClone) {
            this.touchClone.remove();
            this.touchClone = null;
          }

          document.querySelectorAll('.playlist-item.dragging').forEach(el => {
            el.classList.remove('dragging');
          });

          // Revert the in-progress reorder back to the last saved state
          this.render(true); // don't scroll ‚Äî cancelled drag, leave list where it is
          debugLog('Touch drag cancelled by browser');
        }

        // Scrolls #playlist-display only if the playing item isn't already
        // fully visible. Uses getBoundingClientRect so the position is always
        // relative to the visible viewport of the container, not a DOM ancestor.
        scrollToCurrentSong() {
          const container = document.getElementById('playlist-display');
          const activeItem = container.querySelector('.current-playing');
          if (!activeItem) return;

          const cRect = container.getBoundingClientRect();
          const iRect = activeItem.getBoundingClientRect();

          // Already fully visible ‚Äî don't touch the scroll position
          if (iRect.top >= cRect.top && iRect.bottom <= cRect.bottom) return;

          // Scroll the minimum needed so the item sits 16px from the top edge
          const targetScrollTop = container.scrollTop + (iRect.top - cRect.top) - 16;
          container.scrollTo({ top: Math.max(0, targetScrollTop), behavior: 'smooth' });
        }

        // Mid-drag re-render: rebuilds DOM order and data-index values while
        // preserving the dragging class on the active item
        renderForDrag(activeDragIndex) {
          const container = document.getElementById('playlist-display');
          container.innerHTML = this.songs.map((song, index) => {
            const isPlaying = song.id === this.currentSongId;
            const playingClass = isPlaying ? 'current-playing' : '';
            const isDragging = index === activeDragIndex ? 'dragging' : '';
            const playBtnText = isPlaying ? '‚è∏Ô∏è Playing' : '‚ñ∂Ô∏è Play';
            return `
              <div class="playlist-item ${playingClass} ${isDragging}"
                   draggable="true"
                   data-song-id="${song.id}"
                   data-index="${index}">
                <span class="drag-handle">‚ãÆ‚ãÆ</span>
                <span class="song-number">${index + 1}.</span>
                <span class="song-name"><span class="song-text">${song.filename}</span></span>
                <button class="play-song-btn"
                        onclick="playlistManager.playSong('${song.id}')"
                        ${player.isInRadioMode() ? 'disabled' : ''}>
                  ${playBtnText}
                </button>
              </div>
            `;
          }).join('');
          this.setupDragAndDrop();
        }

        playSong(songId) {
          if (player.isInRadioMode()) {
            alert('Cannot change songs while in radio mode');
            return;
          }

          this.currentSongId = songId;
          const song = this.songs.find(s => s.id === songId);
          
          audio.src = `/player/stream/id/${songId}`;
          audio.load();
          audio.play();
          
          // Update the player controls display
          if (song) {
            const songIndex = this.songs.findIndex(s => s.id === songId);
            document.querySelector('#player-controls .song-info strong').nextSibling.textContent = ' ' + song.filename;
            document.querySelector('#player-controls div:last-child').textContent = `Track ${songIndex + 1} of ${this.songs.length}`;
          }
          
          this.render();
          debugLog(`Playing: ${song ? song.filename : songId}`);
        }

        getSongById(songId) {
          return this.songs.find(s => s.id === songId);
        }

        getCurrentIndex() {
          if (!this.currentSongId) return 0;
          return this.songs.findIndex(s => s.id === this.currentSongId);
        }

        getNextSong() {
          const currentIndex = this.getCurrentIndex();
          const nextIndex = (currentIndex + 1) % this.songs.length;
          return this.songs[nextIndex];
        }

        getPrevSong() {
          const currentIndex = this.getCurrentIndex();
          const prevIndex = currentIndex === 0 ? this.songs.length - 1 : currentIndex - 1;
          return this.songs[prevIndex];
        }

        playNext() {
          if (player.isInRadioMode()) return;
          const nextSong = this.getNextSong();
          if (nextSong) {
            this.playSong(nextSong.id);
          }
        }

        playPrev() {
          if (player.isInRadioMode()) return;
          const prevSong = this.getPrevSong();
          if (prevSong) {
            this.playSong(prevSong.id);
          }
        }

        updateCurrentFromAudioSrc() {
          // Extract song ID from current audio src (handles /stream/id/{id})
          const idMatch = audio.src.match(/\/stream\/id\/([^/?]+)/);
          // Extract numeric index from /stream/{index}
          const indexMatch = audio.src.match(/\/stream\/(\d+)(?:\?|$)/);
          
          if (idMatch) {
            this.currentSongId = idMatch[1];
            this.render();
          } else if (indexMatch) {
            // Map the server numeric index back to a song ID using original order
            const index = parseInt(indexMatch[1]);
            const songId = this.getSongIdByServerIndex(index);
            if (songId) {
              this.currentSongId = songId;
              this.render();
            }
          }
        }
      }

      // Helper function for reset button
      function resetPlaylistOrder() {
        if (confirm('Reset playlist to default order?')) {
          playlistManager.resetToDefaultOrder();
        }
      }

      // Radio Player Class
      class RadioPlayer {
        constructor(audioElement, sessionId) {
          this.audio = audioElement;
          this.sessionId = sessionId;
          this.mode = "private";
          this.tunedBroadcaster = null;
          this.ws = null;
          this.heartbeatInterval = null;
          this.targetTime = 0;
          this.isBroadcasting = false;
          this.isStartingBroadcast = false;
          this.wakeLock = null;
          this.pageHiddenAt = null;

          // Reconnection state
          this.reconnectAttempts = 0;
          this.maxReconnectAttempts = 10;
          this.baseReconnectDelay = 500;
          this.maxReconnectDelay = 30000;
          this.reconnectTimer = null;
          this.isIntentionalDisconnect = false;

          // Event listener tracking for cleanup
          this.boundHandlers = new Map();
          this.audioEventHandlers = new Map();

          // Connection state for UI
          this.connectionState = "disconnected";

          debugLog(`Initialized with session ID: ${sessionId}`);
          
          // Setup page visibility handling
          this.setupPageVisibilityHandling();
        }

        isMobile() {
          return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
            navigator.userAgent
          );
        }

        setupPageVisibilityHandling() {
          let visibilityProp = 'hidden';
          let visibilityEvent = 'visibilitychange';
          
          if (typeof document.hidden !== 'undefined') {
            visibilityProp = 'hidden';
            visibilityEvent = 'visibilitychange';
          } else if (typeof document.webkitHidden !== 'undefined') {
            visibilityProp = 'webkitHidden';
            visibilityEvent = 'webkitvisibilitychange';
          }
          
          document.addEventListener(visibilityEvent, () => {
            if (document[visibilityProp]) {
              debugLog("üì± Page hidden - broadcasting may be affected on mobile");
              this.onPageHidden();
            } else {
              debugLog("üëÅÔ∏è Page visible again");
              this.onPageVisible();
            }
          });
        }

        onPageHidden() {
          this.pageHiddenAt = Date.now();
          
          if (this.isBroadcasting) {
            debugLog("üì± Page backgrounded - JavaScript will be throttled");
            // DON'T speed up heartbeats - browser throttles anyway, it's pointless
            this.releaseWakeLock();
          }
        }

        onPageVisible() {
          const hiddenDuration = this.pageHiddenAt ? (Date.now() - this.pageHiddenAt) / 1000 : 0;
          this.pageHiddenAt = null;
          
          debugLog(`üëÅÔ∏è Page visible again (was hidden for ${hiddenDuration.toFixed(1)}s)`);
          
          // Reconnect if needed
          if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
            debugLog("WebSocket disconnected, reconnecting...");
            this.connectWebSocket();
          }
          
          if (this.isBroadcasting) {
            // If we were hidden for less than 40 seconds, just resume broadcasting
            // The server's timeout is 45s, so if we were hidden < 40s, we should still be valid
            if (hiddenDuration < 40) {
              debugLog("‚úì Resuming broadcast (short background duration)");
              
              // Re-acquire wake lock
              this.requestWakeLock();
              
              // Send an immediate heartbeat to tell server we're still here
              if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                this.sendHeartbeat();
              }
            } else {
              // We were backgrounded for a long time, server probably cleaned us up
              debugLog("‚ö†Ô∏è Long background duration - verifying broadcast state");
              this.verifyBroadcastState();
            }
          }
        }

        async requestWakeLock() {
          if (!('wakeLock' in navigator)) {
            debugLog("Wake Lock API not supported");
            return;
          }
          
          try {
            this.wakeLock = await navigator.wakeLock.request('screen');
            debugLog("‚úì Wake lock acquired - screen will stay on");
            
            this.wakeLock.addEventListener('release', () => {
              debugLog("Wake lock released");
            });
          } catch (err) {
            debugLog(`Wake lock error: ${err.message}`);
          }
        }

        async releaseWakeLock() {
          if (this.wakeLock) {
            try {
              await this.wakeLock.release();
              this.wakeLock = null;
              debugLog("Wake lock released");
            } catch (err) {
              debugLog(`Wake lock release error: ${err.message}`);
            }
          }
        }

        async verifyBroadcastState() {
          if (!this.ws || this.ws.readyState !== WebSocket.OPEN) return;
          
          const msg = {
            type: "QueryBroadcastState",
            session_id: this.sessionId
          };
          
          debugLog("‚Üí Querying broadcast state from server");
          this.ws.send(JSON.stringify(msg));
        }

        getReconnectDelay() {
          const exponential =
            this.baseReconnectDelay * Math.pow(2, this.reconnectAttempts);
          const jitter = exponential * 0.2 * (Math.random() - 0.5);
          const delay = Math.min(
            Math.max(this.baseReconnectDelay, exponential + jitter),
            this.maxReconnectDelay,
          );
          return delay;
        }

        updateConnectionState(newState) {
          this.connectionState = newState;
          this.notifyConnectionChange(newState);
        }

        notifyConnectionChange(state) {
          const indicator = document.getElementById('connection-indicator');
          const text = document.getElementById('connection-text');
          
          const states = {
            connected: { icon: 'üü¢', text: 'Connected', color: '#28a745' },
            connecting: { icon: 'üü°', text: 'Connecting...', color: '#ffc107' },
            disconnected: { icon: '‚ö™', text: 'Disconnected', color: '#6c757d' },
            error: { icon: 'üî¥', text: 'Connection Error', color: '#dc3545' }
          };
          
          const config = states[state] || states.disconnected;
          indicator.textContent = config.icon;
          text.textContent = config.text;
          text.style.color = config.color;
          
          const event = new CustomEvent("connectionStateChange", {
            detail: {
              state,
              attempt: this.reconnectAttempts,
              maxAttempts: this.maxReconnectAttempts,
            },
          });
          document.dispatchEvent(event);
        }

        connectWebSocket() {
          if (
            this.ws &&
            (this.ws.readyState === WebSocket.OPEN ||
              this.ws.readyState === WebSocket.CONNECTING)
          ) {
            debugLog(
              `WebSocket already ${this.ws.readyState === WebSocket.OPEN ? "connected" : "connecting"}, skipping...`,
            );
            return;
          }

          if (this.reconnectTimer) {
            clearTimeout(this.reconnectTimer);
            this.reconnectTimer = null;
          }

          this.updateConnectionState("connecting");

          const protocol =
            window.location.protocol === "https:" ? "wss:" : "ws:";
          const wsUrl = `${protocol}//${window.location.host}/player/radio`;

          debugLog(
            `Connecting to WebSocket: ${wsUrl} (attempt ${this.reconnectAttempts + 1})`,
          );

          try {
            this.ws = new WebSocket(wsUrl);
          } catch (error) {
            debugLog(`Failed to create WebSocket: ${error.message}`);
            this.scheduleReconnect();
            return;
          }

          const onOpen = () => {
            debugLog("‚úì WebSocket connected");
            this.reconnectAttempts = 0;
            this.updateConnectionState("connected");

            // DON'T auto-resume broadcasting - verify first
            if (this.isBroadcasting) {
              debugLog("Client thinks it's broadcasting - verifying with server");
              this.verifyBroadcastState();
            }

            if (this.tunedBroadcaster) {
              debugLog(
                `Re-tuning to ${this.tunedBroadcaster} after reconnection`,
              );
              this.tuneIn(this.tunedBroadcaster);
            }
          };

          const onMessage = (event) => {
            debugLog(`‚Üê Received: ${event.data}`);
            try {
              const msg = JSON.parse(event.data);
              this.handleRadioMessage(msg);
            } catch (error) {
              debugLog(`Failed to parse message: ${error.message}`);
            }
          };

          const onError = (error) => {
            debugLog(`‚úó WebSocket error`);
            this.updateConnectionState("error");
          };

          const onClose = (event) => {
            debugLog(
              `WebSocket closed (code: ${event.code}, clean: ${event.wasClean})`,
            );
            this.updateConnectionState("disconnected");

            this.removeWebSocketHandlers();

            if (!this.isIntentionalDisconnect) {
              this.scheduleReconnect();
            } else {
              debugLog("Intentional disconnect, not reconnecting");
              this.isIntentionalDisconnect = false;
            }
          };

          this.boundHandlers.set("open", onOpen);
          this.boundHandlers.set("message", onMessage);
          this.boundHandlers.set("error", onError);
          this.boundHandlers.set("close", onClose);

          this.ws.addEventListener("open", onOpen);
          this.ws.addEventListener("message", onMessage);
          this.ws.addEventListener("error", onError);
          this.ws.addEventListener("close", onClose);
        }

        scheduleReconnect() {
          if (this.reconnectAttempts >= this.maxReconnectAttempts) {
            debugLog(
              `Max reconnection attempts (${this.maxReconnectAttempts}) reached`,
            );
            this.updateConnectionState("error");
            alert(
              "Unable to connect to server after multiple attempts. Please refresh the page.",
            );
            return;
          }

          const delay = this.getReconnectDelay();
          debugLog(
            `Scheduling reconnection in ${delay}ms (attempt ${this.reconnectAttempts + 1}/${this.maxReconnectAttempts})`,
          );

          this.reconnectTimer = setTimeout(() => {
            this.reconnectAttempts++;
            this.connectWebSocket();
          }, delay);
        }

        removeWebSocketHandlers() {
          if (!this.ws) return;

          this.boundHandlers.forEach((handler, event) => {
            this.ws.removeEventListener(event, handler);
          });
          this.boundHandlers.clear();
        }

        disconnect() {
          this.isIntentionalDisconnect = true;

          if (this.reconnectTimer) {
            clearTimeout(this.reconnectTimer);
            this.reconnectTimer = null;
          }

          if (this.isBroadcasting) {
            this.stopBroadcasting();
          }

          if (this.ws) {
            this.removeWebSocketHandlers();
            if (
              this.ws.readyState === WebSocket.OPEN ||
              this.ws.readyState === WebSocket.CONNECTING
            ) {
              this.ws.close();
            }
            this.ws = null;
          }

          this.updateConnectionState("disconnected");
          debugLog("Disconnected");
        }

        handleRadioMessage(msg) {
          if (msg.type === "Sync" && msg.broadcaster_id === this.sessionId) {
            return;
          }

          debugLog(`Handling message type: ${msg.type}, mode: ${this.mode}`);

          if (msg.type === "Analytics") {
            updateAnalyticsDisplay(msg);
            return;
          }

          if (msg.type === "BroadcastStateResponse") {
            debugLog(`Server says broadcasting: ${msg.is_broadcasting}, client thinks: ${this.isBroadcasting}`);
            
            if (msg.is_broadcasting !== this.isBroadcasting) {
              debugLog(`‚ö†Ô∏è State mismatch detected!`);
              
              if (msg.is_broadcasting && !this.isBroadcasting) {
                // Server thinks we're broadcasting but we're not - sync to server
                this.isBroadcasting = true;
                this.updateBroadcastingUI(true);
                if (this.isMobile()) {
                  document.getElementById('mobile-warning').classList.remove('hidden');
                }
              } else if (!msg.is_broadcasting && this.isBroadcasting) {
                // Server says we're not broadcasting, but we think we are
                // This likely happened due to tab backgrounding - just resume broadcasting
                debugLog("üîÑ Server lost our session - resuming broadcast automatically");
                
                const wasPlaying = !this.audio.paused;
                const currentTime = this.audio.currentTime;
                const currentIndex = this.getCurrentSongIndex();
                
                const initMsg = {
                  type: "StartBroadcasting",
                  broadcaster_id: this.sessionId,
                  song_index: currentIndex,
                  playback_time: currentTime,
                  is_playing: wasPlaying,
                };
                
                debugLog(`‚Üí Resuming broadcast: song ${initMsg.song_index}, time ${initMsg.playback_time.toFixed(2)}s`);
                
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                  this.ws.send(JSON.stringify(initMsg));
                }
              }
            }
            return;
          }

          if (msg.type === "Error") {
            debugLog(`Server error: ${msg.message}`);
            
            if (msg.message.includes("BroadcasterNotFound") || 
                msg.message.includes("not broadcasting")) {
              
              if (this.isBroadcasting) {
                debugLog("Server rejected broadcast - stopping");
                this.stopBroadcasting();
                alert("Your broadcast session ended. Please start broadcasting again if needed.");
              }
            } else {
              alert(`Error: ${msg.message}`);
            }
            return;
          }

          if (msg.type === "BroadcasterOffline") {
            if (this.tunedBroadcaster === msg.broadcaster_id) {
              debugLog(`Broadcaster ${msg.broadcaster_id} went offline`);
              alert(
                "The broadcaster you were listening to has stopped broadcasting.",
              );
              this.tuneOut("broadcaster_offline");
            }
            return;
          }

          if (msg.type === "BroadcasterOnline") {
            if (this.tunedBroadcaster === msg.broadcaster_id) {
              debugLog(`User ${msg.broadcaster_id} is now broadcasting`);
            }
            return;
          }

          if (this.mode !== "radio") return;

          switch (msg.type) {
            case "Sync":
              this.syncToBroadcaster(msg);
              break;
            case "Heartbeat":
              this.adjustForDrift(msg);
              break;
          }
        }

        syncToBroadcaster(msg) {
          const { song_index, playback_time, is_playing, server_timestamp_ms } =
            msg;

          const currentIndex = this.getCurrentSongIndex();

          if (currentIndex !== song_index) {
            // Broadcaster switched to a different song.
            // Load the new track and defer the seek until canplay fires ‚Äî
            // seeking before the browser has buffered any data causes the
            // half-second skip at the start of every song change.
            debugLog(`Switching from song ${currentIndex} to song ${song_index}`);

            const songId = window.playlistManager
              ? window.playlistManager.getSongIdByServerIndex(song_index)
              : null;

            if (songId) {
              this.audio.src = `/player/stream/id/${songId}`;
            } else {
              // Fall back to numeric index if playlist manager isn't ready yet
              this.audio.src = `/player/stream/${song_index}`;
            }
            this.audio.load();

            // Recalculate target time fresh inside canplay so network latency
            // between the Sync message arriving and the browser being ready to
            // seek is accounted for.
            // Exception: if the broadcaster's playback_time is near 0, the song
            // just started ‚Äî adding latency compensation would skip the opening
            // notes, so we just seek to 0 instead.
            this.audio.addEventListener('canplay', () => {
              let seekTo;
              if (playback_time < 1.0) {
                // Song just started on broadcaster side ‚Äî begin from the top
                seekTo = 0;
              } else {
                const freshElapsed = (Date.now() - server_timestamp_ms) / 1000;
                seekTo = Math.max(0, playback_time + freshElapsed);
              }
              debugLog(`canplay ‚Äî seeking to ${seekTo.toFixed(2)}s (broadcaster at ${playback_time.toFixed(2)}s)`);
              this.audio.currentTime = seekTo;
              if (is_playing) this.audio.play();
            }, { once: true });

          } else {
            // Same song ‚Äî sync position and play state directly, no load needed
            const now = Date.now();
            const elapsed = (now - server_timestamp_ms) / 1000;
            this.targetTime = is_playing
              ? playback_time + elapsed
              : playback_time;

            this.audio.currentTime = this.targetTime;
            if (is_playing && this.audio.paused) this.audio.play();
            if (!is_playing && !this.audio.paused) this.audio.pause();
          }
        }

        adjustForDrift(msg) {
          if (this.audio.paused) return;

          const { playback_time, server_timestamp_ms } = msg;

          const now = Date.now();
          const elapsed = (now - server_timestamp_ms) / 1000;
          this.targetTime = playback_time + elapsed;

          const drift = Math.abs(this.audio.currentTime - this.targetTime);

          if (drift > 0.25) {
            debugLog(`Drift: ${drift.toFixed(3)}s - correcting`);
            this.audio.currentTime = this.targetTime;
          }
        }

        tuneIn(broadcasterId) {
          if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
            debugLog("WebSocket not ready, connecting...");
            this.connectWebSocket();
            setTimeout(() => this.tuneIn(broadcasterId), 500);
            return;
          }

          if (
            this.tunedBroadcaster &&
            this.tunedBroadcaster !== broadcasterId
          ) {
            debugLog(
              `Switching from ${this.tunedBroadcaster} to ${broadcasterId}`,
            );
            this.ws.send(JSON.stringify({ type: "TuneOut" }));
          }

          // Snapshot private playback state so we can restore it on tune out.
          // Only save when entering radio mode for the first time (not when
          // switching between broadcasters).
          if (this.mode !== "radio") {
            this.preRadioSnapshot = {
              src: this.audio.src
                || this.audio.querySelector?.('source')?.getAttribute('src')
                || null,
              currentTime: this.audio.currentTime,
              paused: this.audio.paused,
              songId: window.playlistManager?.currentSongId ?? null,
            };
            debugLog(`üì∏ Saved pre-radio state: ${this.preRadioSnapshot.src} @ ${this.preRadioSnapshot.currentTime.toFixed(2)}s`);
          }

          this.mode = "radio";
          this.tunedBroadcaster = broadcasterId;

          const msg = {
            type: "TuneIn",
            broadcaster_id: broadcasterId,
          };

          debugLog(`‚Üí Sending TuneIn: ${JSON.stringify(msg)}`);
          this.ws.send(JSON.stringify(msg));

          audio.controls = false;
          
          // Re-render playlist to disable controls in radio mode
          if (window.playlistManager) {
            window.playlistManager.render();
          }
        }

        tuneOut(reason = "manual") {
          debugLog(`Leaving radio mode: ${reason}`);

          if (this.ws && this.ws.readyState === WebSocket.OPEN) {
            this.ws.send(JSON.stringify({ type: "TuneOut" }));
          }

          this.mode = "private";
          this.tunedBroadcaster = null;

          modeDisplay.textContent = "Private Mode";
          modeDisplay.className = "mode-badge private";
          broadcasterInfo.classList.add("hidden");

          tuneOutBtn.classList.add("hidden");
          tuneInBtn.classList.remove("hidden");

          prevBtn.disabled = false;
          nextBtn.disabled = false;
          audio.controls = true;

          // Restore private playback state from before tuning in
          if (this.preRadioSnapshot) {
            const snap = this.preRadioSnapshot;
            this.preRadioSnapshot = null;

            if (snap.src) {
              debugLog(`‚Ü©Ô∏è Restoring pre-radio state: ${snap.src} @ ${snap.currentTime.toFixed(2)}s`);
              this.audio.src = snap.src;
              this.audio.load();

              // Restore position and play state once the browser is ready
              this.audio.addEventListener('canplay', () => {
                this.audio.currentTime = snap.currentTime;
                if (!snap.paused) {
                  this.audio.play();
                }
              }, { once: true });
            }

            // Restore the playlist manager's current song so next/prev still work
            if (window.playlistManager && snap.songId) {
              window.playlistManager.currentSongId = snap.songId;
            }
          }

          // Re-render playlist to enable controls and restore highlight
          if (window.playlistManager) {
            window.playlistManager.render();
          }
        }

        removeAudioBroadcastListeners() {
          this.audioEventHandlers.forEach((handler, event) => {
            this.audio.removeEventListener(event, handler);
          });
          this.audioEventHandlers.clear();
        }

        sendHeartbeat() {
          if (!this.isBroadcasting) return;
          if (!this.ws || this.ws.readyState !== WebSocket.OPEN) return;
          
          const msg = {
            type: "Heartbeat",
            broadcaster_id: this.sessionId,
            playback_time: this.audio.currentTime,
          };
          
          debugLog(
            `‚Üí Heartbeat: song ${this.getCurrentSongIndex()}, time ${msg.playback_time.toFixed(2)}s`,
          );
          this.ws.send(JSON.stringify(msg));
        }

        startBroadcasting() {
          if (this.isStartingBroadcast) {
            debugLog("Already starting broadcast, ignoring duplicate request");
            return;
          }
          
          this.isStartingBroadcast = true;
          
          if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
            debugLog("WebSocket not ready for broadcasting, connecting...");
            this.isStartingBroadcast = false;
            this.connectWebSocket();
            setTimeout(() => this.startBroadcasting(), 500);
            return;
          }

          if (this.isBroadcasting) {
            debugLog("Already broadcasting, cleaning up first");
            this.stopBroadcasting();
          }

          // Remove any existing listeners first
          this.removeAudioBroadcastListeners();

          this.isBroadcasting = true;
          debugLog(`Broadcasting as: ${this.sessionId}`);

          // Show mobile warning if applicable
          if (this.isMobile()) {
            document.getElementById('mobile-warning').classList.remove('hidden');
          }

          // Request wake lock to prevent screen from sleeping
          this.requestWakeLock();

          const sendUpdate = () => {
            if (!this.isBroadcasting) return;
            if (!this.ws || this.ws.readyState !== WebSocket.OPEN) return;
            
            const msg = {
              type: "BroadcastUpdate",
              broadcaster_id: this.sessionId,
              song_index: this.getCurrentSongIndex(),
              playback_time: this.audio.currentTime,
              is_playing: !this.audio.paused,
            };
            debugLog(
              `‚Üí Broadcasting: song ${msg.song_index}, time ${msg.playback_time.toFixed(2)}s`,
            );
            this.ws.send(JSON.stringify(msg));
          };

          // Store handlers for cleanup
          this.audioEventHandlers.set("play", sendUpdate);
          this.audioEventHandlers.set("pause", sendUpdate);
          this.audioEventHandlers.set("seeked", sendUpdate);

          this.audio.addEventListener("play", sendUpdate);
          this.audio.addEventListener("pause", sendUpdate);
          this.audio.addEventListener("seeked", sendUpdate);

          this.heartbeatInterval = setInterval(() => this.sendHeartbeat(), 2000);

          // Send initial state
          const initMsg = {
            type: "StartBroadcasting",
            broadcaster_id: this.sessionId,
            song_index: this.getCurrentSongIndex(),
            playback_time: this.audio.currentTime,
            is_playing: !this.audio.paused,
          };
          debugLog(
            `‚Üí Starting broadcast: song ${initMsg.song_index}, time ${initMsg.playback_time.toFixed(2)}s`,
          );
          this.ws.send(JSON.stringify(initMsg));
          
          this.updateBroadcastingUI(true);
          this.isStartingBroadcast = false;
        }

        stopBroadcasting() {
          if (!this.isBroadcasting) {
            debugLog("Not broadcasting, nothing to stop");
            return;
          }
          
          this.isBroadcasting = false;

          if (this.heartbeatInterval) {
            clearInterval(this.heartbeatInterval);
            this.heartbeatInterval = null;
          }

          this.removeAudioBroadcastListeners();
          
          // Release wake lock
          this.releaseWakeLock();
          
          // Hide mobile warning
          document.getElementById('mobile-warning').classList.add('hidden');

          if (this.ws && this.ws.readyState === WebSocket.OPEN) {
            this.ws.send(
              JSON.stringify({
                type: "StopBroadcasting",
                broadcaster_id: this.sessionId,
              }),
            );
          }

          this.updateBroadcastingUI(false);
          debugLog("Broadcasting stopped");
        }

        updateBroadcastingUI(isBroadcasting) {
          const broadcastStatus = document.getElementById("broadcast-status");
          const broadcastBtn = document.getElementById("broadcast-btn");
          const stopBroadcastBtn = document.getElementById("stop-broadcast-btn");
          
          if (isBroadcasting) {
            broadcastStatus.classList.remove("hidden");
            broadcastBtn.classList.add("hidden");
            stopBroadcastBtn.classList.remove("hidden");
          } else {
            broadcastStatus.classList.add("hidden");
            stopBroadcastBtn.classList.add("hidden");
            broadcastBtn.classList.remove("hidden");
          }
        }

        // Returns the server's numeric index for the currently playing song.
        // When the audio src is /stream/id/{uuid}, we look up the UUID in the
        // original server playlist order to get the correct index. This index
        // is what gets broadcast to listeners so they can request the same song.
        getCurrentSongIndex() {
          const idMatch = this.audio.src.match(/\/stream\/id\/([^/?]+)/);
          if (idMatch && window.playlistManager) {
            // Resolve UUID to server index using the original unshuffled order
            return window.playlistManager.getServerIndexById(idMatch[1]);
          }

          // Fall back to numeric index in the URL (e.g. initial page load)
          const indexMatch = this.audio.src.match(/\/stream\/(\d+)(?:\?|$)/);
          return indexMatch ? parseInt(indexMatch[1]) : 0;
        }

        isInRadioMode() {
          return this.mode === "radio";
        }
      }

      // Update analytics display with live data
      function updateAnalyticsDisplay(analytics) {
        document.getElementById("stat-connections").textContent =
          analytics.active_connections;
        document.getElementById("stat-broadcasters").textContent =
          analytics.active_broadcasters;
        document.getElementById("stat-listeners").textContent =
          analytics.active_listeners;

        const broadcastersList = document.getElementById("broadcasters-list");

        if (analytics.broadcasters.length === 0) {
          broadcastersList.innerHTML =
            '<div class="no-broadcasters">No one is broadcasting right now</div>';
          return;
        }

        broadcastersList.innerHTML = analytics.broadcasters
          .map((broadcaster) => {
            const playIcon = broadcaster.is_playing ? "‚ñ∂Ô∏è" : "‚è∏Ô∏è";
            const minutes = Math.floor(broadcaster.playback_time / 60);
            const seconds = Math.floor(broadcaster.playback_time % 60);
            const timeStr = `${minutes}:${seconds.toString().padStart(2, "0")}`;

            const isSelf = broadcaster.broadcaster_id === player.sessionId;
            const isTunedIn =
              player.tunedBroadcaster === broadcaster.broadcaster_id;

            let cardClass = "broadcaster-card";
            if (isSelf) {
              cardClass += " self-broadcasting";
            } else if (isTunedIn) {
              cardClass += " currently-tuned";
            }

            let buttonHTML;
            if (isSelf) {
              buttonHTML = '<button class="tune-in-btn" disabled>You</button>';
            } else if (isTunedIn) {
              buttonHTML =
                '<button class="tune-in-btn" disabled>Tuned In ‚úì</button>';
            } else {
              buttonHTML = `<button class="tune-in-btn" onclick="tuneInToBroadcaster('${broadcaster.broadcaster_id}')">Tune In üìª</button>`;
            }

            return `
        <div class="${cardClass}">
          <div class="broadcaster-info-card">
            <div class="broadcaster-id">${broadcaster.broadcaster_id}</div>
            <div class="broadcaster-song">
              <span class="play-status">${playIcon}</span>
              <span>${broadcaster.song_name}</span>
            </div>
            <div class="broadcaster-time">
              Track ${broadcaster.song_index + 1} ‚Ä¢ ${timeStr} ‚Ä¢ 
              <strong>${broadcaster.listener_count || 0} üë•</strong>
            </div>
          </div>
          ${buttonHTML}
        </div>
      `;
          })
          .join("");
      }

      function tuneInToBroadcaster(broadcasterId) {
        document.getElementById("broadcaster-input").value = broadcasterId;

        player.tuneIn(broadcasterId);

        modeDisplay.textContent = "Radio Mode";
        modeDisplay.className = "mode-badge radio";
        broadcasterName.textContent = broadcasterId;
        broadcasterInfo.classList.remove("hidden");

        tuneInBtn.classList.add("hidden");
        tuneOutBtn.classList.remove("hidden");

        prevBtn.disabled = true;
        nextBtn.disabled = true;

        debugLog(
          `Tuned into broadcaster: ${broadcasterId} via broadcaster list`,
        );
      }

      // Initialize
      const audio = document.getElementById("audio-player");
      const sessionId = "{{ session_id }}";
      const player = new RadioPlayer(audio, sessionId);

      player.connectWebSocket();

      // UI Elements
      const tuneInBtn = document.getElementById("tune-in-btn");
      const tuneOutBtn = document.getElementById("tune-out-btn");
      const broadcastBtn = document.getElementById("broadcast-btn");
      const stopBroadcastBtn = document.getElementById("stop-broadcast-btn");
      const broadcasterInput = document.getElementById("broadcaster-input");
      const modeDisplay = document.getElementById("mode-display");
      const broadcastStatus = document.getElementById("broadcast-status");
      const broadcasterInfo = document.getElementById("broadcaster-info");
      const broadcasterName = document.getElementById("broadcaster-name");
      const prevBtn = document.getElementById("prev-btn");
      const nextBtn = document.getElementById("next-btn");

      tuneInBtn.addEventListener("click", () => {
        const broadcasterId = broadcasterInput.value.trim();
        if (!broadcasterId) {
          alert("Please enter a broadcaster session ID");
          return;
        }

        debugLog(`Tuning into broadcaster: ${broadcasterId}`);
        player.tuneIn(broadcasterId);

        modeDisplay.textContent = "Radio Mode";
        modeDisplay.className = "mode-badge radio";
        broadcasterName.textContent = broadcasterId;
        broadcasterInfo.classList.remove("hidden");

        tuneInBtn.classList.add("hidden");
        tuneOutBtn.classList.remove("hidden");

        prevBtn.disabled = true;
        nextBtn.disabled = true;
      });

      tuneOutBtn.addEventListener("click", () => {
        player.tuneOut();
      });

      broadcastBtn.addEventListener("click", () => {
        player.startBroadcasting();
      });

      stopBroadcastBtn.addEventListener("click", () => {
        player.stopBroadcasting();
      });

      // Next/Prev use playlist manager so custom order is respected
      prevBtn.addEventListener("click", () => {
        if (player.isInRadioMode()) {
          alert("Controls disabled while tuned into a radio");
          return;
        }
        playlistManager.playPrev();
      });

      nextBtn.addEventListener("click", () => {
        if (player.isInRadioMode()) {
          alert("Controls disabled while tuned into a radio");
          return;
        }
        playlistManager.playNext();
      });

      // Audio ended handler uses playlist manager
      audio.addEventListener("ended", () => {
        if (player.isInRadioMode()) {
          debugLog(
            "Track ended, but in radio mode ‚Äî waiting for broadcaster",
          );
          return;
        }

        debugLog("Track ended ‚Äî moving to next track");
        playlistManager.playNext();
      });

      window.addEventListener("beforeunload", () => {
        if (window.player) {
          window.player.disconnect();
        }
      });

      window.addEventListener("pagehide", () => {
        if (window.player) {
          debugLog("Page hide detected - cleaning up");
          if (window.player.isBroadcasting) {
            window.player.stopBroadcasting();
          }
          window.player.disconnect();
        }
      });

      // Initialize playlist manager ‚Äî syncCurrentFromAudio is called inside
      // loadPlaylist once song data is available, so the initial audio src is
      // resolved to a song ID before the first render
      const playlistManager = new PlaylistManager(sessionId);
      playlistManager.loadPlaylist();

      // Track current song whenever the audio src changes mid-session
      audio.addEventListener('loadstart', () => {
        playlistManager.updateCurrentFromAudioSrc();
      });

      // Make globally accessible
      window.player = player;
      window.playlistManager = playlistManager;
    </script>
  </body>
</html>