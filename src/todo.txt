Starred@omer.sadikovic


---

## üü° MEDIUM PRIORITY - Performance Improvements

### TODO 6: Add graceful shutdown signaling
**Location:** `handle_radio_connection()` task coordination
**Problem:** Send task might continue after receive task dies
**Fix:** Add oneshot channel for shutdown coordination
```rust
let (shutdown_tx, shutdown_rx) = oneshot::channel();
// Send task listens on shutdown_rx
// Receive task sends on shutdown_tx before exiting
```

---

## üü¢ LOW PRIORITY - Production Hardening

### TODO 7: Implement connection tracking with Drop guard
**Location:** `handle_radio_connection()`
**Problem:** TODOs for increment/decrement never implemented
**Fix:** Create ConnectionGuard struct with Drop impl
```rust
struct ConnectionGuard { state: SharedState }
impl Drop for ConnectionGuard {
    fn drop(&mut self) {
        self.state.total_connections.fetch_sub(1, Ordering::Relaxed);
    }
}
```

### TODO 8: Add timeout protection on mutex locks
**Location:** All `.lock().await` calls
**Problem:** Deadlock if task panics while holding lock
**Fix:** Wrap with `tokio::time::timeout()`
```rust
timeout(Duration::from_secs(5), mutex.lock()).await?
```

### TODO 9: Replace silent error swallowing with proper handling
**Location:** `handle_client_message()` error sending
**Problem:** `let _ = out_tx.send(error_msg).await;` silently fails
**Fix:** Check result and break loop if send fails
```rust
if out_tx.send(error_msg).await.is_err() {
    tracing::error!("Failed to send error, connection closed");
    break;
}
```

### TODO 10: Add backpressure handling for slow clients
**Location:** All `out_tx.send().await` calls
**Problem:** Blocks receive task if client is slow to receive
**Fix:** Use `try_send()` and handle Full error
```rust
match out_tx.try_send(msg) {
    Ok(()) => {}
    Err(TrySendError::Full(_)) => {
        tracing::warn!("Client slow, dropping message");
    }
    Err(TrySendError::Closed(_)) => break,
}
```

---

## üìä OPTIONAL - Observability & Monitoring

### TODO 11: Add metrics for message handling duration
**Location:** `handle_client_message()`
**Fix:** Track slow message handling
```rust
let start = Instant::now();
// ... handle message ...
let duration = start.elapsed();
if duration > Duration::from_millis(100) {
    tracing::warn!("Slow message: {:?} took {:?}", msg, duration);
}
```

### TODO 12: Add broadcaster online/offline notifications
**Location:** Cleanup task and connection handling
**Fix:** Notify listeners when broadcaster disconnects
```rust
// In cleanup task when removing broadcaster:
let _ = state.broadcast_tx.send(RadioMessage::BroadcasterOffline {
    broadcaster_id: id.clone()
});
```

### TODO 13: Add session cleanup background task
**Location:** Main function startup
**Problem:** Session cleanup happens in hot path (`get_or_create_position`)
**Fix:** Move to background task running every 5 minutes
```rust
tokio::spawn(async move {
    let mut interval = interval(Duration::from_secs(300));
    loop {
        interval.tick().await;
        // Clean sessions older than 1 hour
    }
});
```

---

## üèóÔ∏è ARCHITECTURE REFACTORS (Long-term)

### TODO 14: Replace Mutex with message-passing for tuned_broadcaster
**Location:** `handle_radio_connection()`
**Problem:** Shared mutable state via Mutex
**Fix:** Send task owns state, receive task sends commands via channel
```rust
enum SendCommand {
    UpdateTunedBroadcaster(Option<String>),
    SendMessage(RadioMessage),
}
// Send task becomes single owner, no locks needed
```

### TODO 15: Add explicit broadcaster registration/unregistration
**Location:** WebSocket message handling
**Fix:** Add StartBroadcasting / StopBroadcasting messages
```rust
RadioMessage::StartBroadcasting { broadcaster_id }
RadioMessage::StopBroadcasting { broadcaster_id }
```

---

## Priority Order for Implementation:
1. ‚úÖ TODO 3 (cleanup task) - Fixes memory leak
2. ‚úÖ TODO 1 (remove lock from send loop) - Biggest perf win
3. ‚úÖ TODO 2 (per-broadcaster channels) - Biggest scalability win
4. ‚úÖ TODO 4 (remove validation) - Easy perf gain
5. ‚úÖ TODO 7 (connection tracking) - Complete existing TODOs
6. Everything else as time permits

**Estimated impact:** These 5 fixes will get you from ~1000 concurrent users to ~50,000+ concurrent users.